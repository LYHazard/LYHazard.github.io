<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>java 常识内容 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="“&#x3D;”相关在数组类型用“&#x3D;” 进行赋值时 此时赋值的内容是地址，其中一个数组的内容改变，另一个的内容也随之改变 “&#x3D;&#x3D;”符号的相关在比较基本数据类型时”&#x3D;&#x3D;”比较的是数据值 在比较引用数据类型时“&#x3D;&#x3D;”比较的是地址值 字符串相关的底层原理字符串存储的内存原理 直接赋值会复用字符串常量池中的 new出来的不会复用，而是开">
<meta property="og:type" content="article">
<meta property="og:title" content="java 常识内容">
<meta property="og:url" content="http://example.com/2023/01/03/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="“&#x3D;”相关在数组类型用“&#x3D;” 进行赋值时 此时赋值的内容是地址，其中一个数组的内容改变，另一个的内容也随之改变 “&#x3D;&#x3D;”符号的相关在比较基本数据类型时”&#x3D;&#x3D;”比较的是数据值 在比较引用数据类型时“&#x3D;&#x3D;”比较的是地址值 字符串相关的底层原理字符串存储的内存原理 直接赋值会复用字符串常量池中的 new出来的不会复用，而是开">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9.assets/image-20230225165326438.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LYHazard/blog.img/202303022129958.png">
<meta property="og:image" content="http://example.com/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9.assets/image-20230314143330999-16787756136801.png">
<meta property="article:published_time" content="2023-01-03T09:46:20.000Z">
<meta property="article:modified_time" content="2023-03-14T12:05:05.526Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9.assets/image-20230225165326438.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-java-常识内容" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/03/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9/" class="article-date">
  <time class="dt-published" datetime="2023-01-03T09:46:20.000Z" itemprop="datePublished">2023-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      java 常识内容
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="“-x3D-”相关"><a href="#“-x3D-”相关" class="headerlink" title="“&#x3D;”相关"></a>“&#x3D;”相关</h1><p>在数组类型用“&#x3D;” 进行赋值时 此时赋值的内容是地址，其中一个数组的内容改变，另一个的内容也随之改变</p>
<h1 id="“-x3D-x3D-”符号的相关"><a href="#“-x3D-x3D-”符号的相关" class="headerlink" title="“&#x3D;&#x3D;”符号的相关"></a>“&#x3D;&#x3D;”符号的相关</h1><p>在比较基本数据类型时”&#x3D;&#x3D;”比较的是数据值</p>
<p>在比较引用数据类型时“&#x3D;&#x3D;”比较的是地址值</p>
<h1 id="字符串相关的底层原理"><a href="#字符串相关的底层原理" class="headerlink" title="字符串相关的底层原理"></a>字符串相关的底层原理</h1><h2 id="字符串存储的内存原理"><a href="#字符串存储的内存原理" class="headerlink" title="字符串存储的内存原理"></a>字符串存储的内存原理</h2><ul>
<li>直接赋值会复用字符串常量池中的</li>
<li>new出来的不会复用，而是开辟一个新的空间</li>
</ul>
<h2 id="字符串拼接的底层原理"><a href="#字符串拼接的底层原理" class="headerlink" title="字符串拼接的底层原理"></a>字符串拼接的底层原理</h2><ul>
<li>在拼接时没有变量全是字符串的情况下，触发字符串的优化机制。在编译时就已经是最终结果了，会复用串池中的字符串</li>
<li>在拼接时有变量参与的情况下，会创建一个StringBuilder对象将相应的变量进行相加，每相加一个就创建一个新的StringBuilder，最后再使用toString方法转换成String返回，但toString方法底层原理是创建一个String对象，所以带有变量拼接是比较麻烦的且浪费内存</li>
<li>在JDK8之后会对字符串拼接的时候会对每个相加进行预估，作用并不明显</li>
</ul>
<h2 id="StringBuilder源码分析"><a href="#StringBuilder源码分析" class="headerlink" title="StringBuilder源码分析"></a>StringBuilder源码分析</h2><ul>
<li>默认创建一个长度为16的字节数组</li>
<li>添加的内容长度小于16，直接存</li>
<li>添加的内容大于16会扩容（原来的容量*2+2）</li>
<li>如果扩容之后还不够，以实际长度为准</li>
</ul>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>static表示静态，是java中的一个修饰符，可以修饰成员方法，成员变量</p>
<p>static变量是共享的 放在静态存储区中 </p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h1 id="继承中构造方法的访问特点"><a href="#继承中构造方法的访问特点" class="headerlink" title="继承中构造方法的访问特点"></a>继承中构造方法的访问特点</h1><ul>
<li>子类不能继承父类的构造方法，但是能够通过super调用</li>
<li>子类构造方法的第一行，有一个默认的super()</li>
<li>默认先访问父类中无参的构造方法，再执行自己的</li>
<li>如果想要访问父类有参构造，必须手动书写</li>
</ul>
<h2 id="this-super的概念总结"><a href="#this-super的概念总结" class="headerlink" title="this,super的概念总结"></a>this,super的概念总结</h2><ul>
<li><strong>this相当于一个局部变量</strong>，表示当前方法调用者的地址值</li>
<li>super：代表父类存储空间</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="单列集合"><a href="#单列集合" class="headerlink" title="单列集合"></a>单列集合</h2><p>List系列集合：添加的元素是 <strong>有序、有重复、有索引</strong></p>
<p>set系列集合：添加的元素是 <strong>无序、不重复、无索引</strong></p>
<h2 id="集合遍历-Iterator"><a href="#集合遍历-Iterator" class="headerlink" title="集合遍历 Iterator"></a>集合遍历 Iterator</h2><p>迭代器在Java中的类是Iterator，迭代器是集合专用的遍历方式</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul>
<li>调用成员变量：编译看左边，运行也看左边<ul>
<li>编译看左边：javac编译代码的时候，会看左边父类中有没有这个变量，如果有，编译成功，如果没有编译失败。</li>
<li>运行也看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值</li>
</ul>
</li>
<li>调用成员方法：编译看左边，运行看右边<ul>
<li>编译看左边：javac编译代码的时候，会看左边父类中有没有这个变量，如果有，编译成功，如果没有编译失败。</li>
<li>运行看右边：java运行代码的时候，实际上运行的子类中的方法</li>
</ul>
</li>
</ul>
<h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><p>方法中，使用父类型作为参数，可以接收所有子类对象</p>
<h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能使用子类的特有功能</p>
<h2 id="引用数据类型的类型转换，有几种方式"><a href="#引用数据类型的类型转换，有几种方式" class="headerlink" title="引用数据类型的类型转换，有几种方式"></a>引用数据类型的类型转换，有几种方式</h2><ul>
<li><p>自动类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制类型转换</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student)p;</span><br></pre></td></tr></table></figure>

<h2 id="强制类型转换能解决什么问题"><a href="#强制类型转换能解决什么问题" class="headerlink" title="强制类型转换能解决什么问题"></a>强制类型转换能解决什么问题</h2><ul>
<li>可以转换成真正的子类类型，从而调用子类独有的功能</li>
<li>转换类型与真实类型不一致会报错</li>
<li>转换的时候用instanceof关键字进行判断</li>
</ul>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="内部类的访问特点"><a href="#内部类的访问特点" class="headerlink" title="内部类的访问特点"></a>内部类的访问特点</h2><ul>
<li>内部类可以直接访问外部类的成员，包括私有</li>
<li>外部类要访问内部类的成员，必须创建对象</li>
</ul>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ul>
<li>静态内部类也是成员内部类中的一种</li>
<li>静态内部类智能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建外部类的对象</li>
<li>创建静态内部类对象的格式<ul>
<li>外部类名.内部类名 对象名 &#x3D; new 外部类目.内部类名();</li>
</ul>
</li>
<li>调用静态方法的格式<ul>
<li>外部类名.内部类名.方法名（）；</li>
</ul>
</li>
</ul>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类的本质就是隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置</p>
<h2 id="匿名内部类的格式"><a href="#匿名内部类的格式" class="headerlink" title="匿名内部类的格式"></a>匿名内部类的格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类名或者接口名()&#123;</span><br><span class="line">	重写方法;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="格式的细节"><a href="#格式的细节" class="headerlink" title="格式的细节"></a>格式的细节</h2><ul>
<li>包含了继承或实现，方法重写，创建对象</li>
<li>整体就是一个类的子类对象或者接口的实现类对象</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当方法的参数是接口或者类时，以接口为例，可以传递这个接口的实现类对象，如果实现类只要使用一次，就可以使用匿名内部类简化代码。</p>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><ul>
<li><strong>object是java中的顶级父类</strong></li>
</ul>
<p>所有的类都直接或间接的继承于Object类。</p>
<ul>
<li><strong>toString（）：</strong>一般都会重写，打印对象时打印属性</li>
<li><strong>equals()：</strong>比较对象的时候会重写，比较对象属性值是否相同</li>
<li><strong>clone()：</strong>默认浅克隆，如果需要深克隆需要重写方法或者使用第三方工具类</li>
</ul>
<h1 id="objects类"><a href="#objects类" class="headerlink" title="objects类"></a>objects类</h1><ul>
<li>**equals():**对比object类的equals方法 多一个空参判断</li>
</ul>
<h1 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h1><h2 id="BigInteger-对象获取"><a href="#BigInteger-对象获取" class="headerlink" title="BigInteger 对象获取"></a>BigInteger 对象获取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">b1</span> <span class="operator">=</span> BigInteger.valueof(<span class="number">0.1</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;整数&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><ul>
<li>加：add</li>
<li>减: subtract</li>
<li>乘：multiply</li>
<li>除：divide、divideAndRemainder</li>
<li>比较：equals、max、min</li>
<li>次幂：pow</li>
<li>转成整数：intValue、longValue</li>
</ul>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>对象获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建正则表达式的规则</span></span><br><span class="line">String regex;</span><br><span class="line"><span class="comment">//按照正则表达式的规则，去获取数据</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"><span class="comment">//按照pattern的规则去字符串中获取数据</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(字符串);</span><br><span class="line"><span class="keyword">while</span>(matcher.find)&#123;</span><br><span class="line">    <span class="comment">//group即为根据正则表达式筛选出来的数据</span></span><br><span class="line">    <span class="comment">//index表示获取正则表达式中的第几组数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> matcher.group(index);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h1><h2 id="Collection-单列集合"><a href="#Collection-单列集合" class="headerlink" title="Collection 单列集合"></a>Collection 单列集合</h2><ul>
<li><p>List ：<strong>添加的元素是有序的、可重复、有索引</strong></p>
<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector（已被淘汰）</li>
</ul>
</li>
<li><p>Set：<strong>无序、不重复、无索引</strong></p>
<ul>
<li>HashSet：无序、不重复、无索引<ul>
<li>LinkedHashSet：有序、不重复、无索引</li>
</ul>
</li>
<li>TreeSet：可排序、不重复、无索引</li>
</ul>
</li>
</ul>
<p>如果在遍历过程中需要删除元素，就使用<strong>迭代器</strong></p>
<p>如果仅仅是想遍历，那么使用<strong>增强for</strong>或者<strong>Lambda表达式</strong></p>
<h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><p>​	迭代器在Java中的类是Iterator，迭代器是集合专用的遍历方式</p>
<p><strong>Collection集合获取迭代器</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Iterator<E> iterator()</td>
<td>返回迭代器对象，默认指向当前集合的0索引</td>
</tr>
</tbody></table>
<p><strong>Iterator中的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext(）</td>
<td>判断当前位置是否有元素，有元素返回true,没有元素返回false</td>
</tr>
<tr>
<td>E next()</td>
<td>获取当前位置的元素，并将迭代器对象移向下一个位置</td>
</tr>
</tbody></table>
<p><strong>迭代器的四个细节</strong></p>
<ul>
<li>如何当前位置没有元素，还要强行获取，会报NoSuchElementException</li>
<li>迭代器遍历完毕，指针不会复位</li>
<li>循环中只能用一次next方法</li>
<li>迭代器遍历时，不能用集合的方法进行增加或者删除</li>
</ul>
<h3 id="增强for遍历"><a href="#增强for遍历" class="headerlink" title="增强for遍历"></a>增强for遍历</h3><ul>
<li>增强for的底层就是迭代器，为了简化迭代器的代码书写的</li>
<li>它是JDK5之后出现的，其内部原理就是一个Iterator迭代器</li>
<li>所有的单列集合和数组才能使用增强for进行遍历</li>
</ul>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>（元素的数据类型 变量名 ： 数组或者集合）</span><br></pre></td></tr></table></figure>

<p> <strong>增强for的细节</strong></p>
<ul>
<li>修改增强for中的变量，不会改变集合中原本的数据</li>
</ul>
<h3 id="Lambda-表达式遍历"><a href="#Lambda-表达式遍历" class="headerlink" title="Lambda 表达式遍历"></a>Lambda 表达式遍历</h3><ul>
<li>其实也会自己遍历集合，依次得到每一个元素</li>
<li>把得到的每一个元素，传递给下面的accept方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>default void forEach(Consumer&lt;? super T&gt;action):</td>
<td>结合lambda遍历集合</td>
</tr>
</tbody></table>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul>
<li>在调用方法的时候，如果方法出现了重载现象，优先调用 <strong>实参跟形参类型一致的那个方法</strong></li>
</ul>
<p>在遍历的方法中添加了一个列表迭代器，在需要<strong>添加元素</strong>的时候可以使用</p>
<h3 id="ArrayList集合底层原理"><a href="#ArrayList集合底层原理" class="headerlink" title="ArrayList集合底层原理"></a>ArrayList集合底层原理</h3><ol>
<li>利用空参创建的集合，在底层创建一个默认长度为0的数组</li>
<li>添加第一个元素时，底层会创建一个新的长度为10的数组 &#x2F;&#x2F; </li>
<li>存满时，会扩容1.5倍（grow（）函数 第一次扩容是添加10长度，第二次之后是通过ArraysSupport的newLength函数如果长度大于1.5倍则选择增加所需长度）</li>
<li>如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准</li>
</ol>
<h3 id="LinkedList集合底层原理"><a href="#LinkedList集合底层原理" class="headerlink" title="LinkedList集合底层原理"></a>LinkedList集合底层原理</h3><ul>
<li>底层数据结构是双链表，查询慢，增删快，但是如果操作的是首尾元素，速度也是极快的。</li>
<li>LinkedList本身多了很多直接操作首尾元素的特有API</li>
</ul>
<table>
<thead>
<tr>
<th>特有方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void addFirst(E e)</td>
<td>在该列表的开头插入指定的元素</td>
</tr>
<tr>
<td>void addLast(E e)</td>
<td>将指定的元素追加到此列表的末尾</td>
</tr>
<tr>
<td>E getFirst()</td>
<td>返回此列表的第一个元素</td>
</tr>
<tr>
<td>E getLast()</td>
<td>返回此列表中的最后一个元素</td>
</tr>
<tr>
<td>E removeFirst()</td>
<td>删除第一个元素</td>
</tr>
<tr>
<td>E removeLast()</td>
<td>删除最后一个元素</td>
</tr>
</tbody></table>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul>
<li>HashSet集合底层采取 <strong>哈希表</strong>存储数据</li>
<li>哈希表是一种对于增删改查数据性能都较好的结构</li>
<li>哈希表的组成，在JDK8之前是数组+链表，JDK8之后是数组+链表+红黑树</li>
</ul>
<h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><ul>
<li>根据hashCode方法算出来的int类型的整数</li>
<li>该方法定义在Object类中，所有对象都可以调用，默认使用地址值进行计算</li>
<li>一般情况下，会重写hashCode方法，利用对象内部的属性值计算哈希值</li>
</ul>
<p><strong>对象的哈希值特点</strong>：</p>
<ul>
<li>如果没有重写hashCode方法，不同对象计算出的哈希值是不同的</li>
<li>如果已经重写hashCode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的</li>
<li>在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样（哈希碰撞）</li>
</ul>
<h4 id="HashSet底层原理"><a href="#HashSet底层原理" class="headerlink" title="HashSet底层原理"></a>HashSet底层原理</h4><ol>
<li>创建一个默认长度为16，默认加载因子为0.75的数组，数组名为table</li>
<li>根据元素的哈希值跟数组的长度计算出应该存入的位置</li>
<li>判断当前位置是否为null，如果是null直接存入</li>
<li>如果位置不为null，表示有元素，则调用equals方法比较属性值</li>
<li>一样： 不存       不一样：存入数组，形成链表 </li>
<li>在JDK8之前：新元素存入数组，老元素挂在新元素下面，JDK8之后：新元素直接挂在老元素下面</li>
<li>JDK8之后，链表长度超过8，而且数组长度大于等于64时，自动转换成红黑树</li>
<li>如果集合中存储的是自定义对象，必须要重写hashCode和equals方法</li>
</ol>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><ul>
<li><p>有序、不重复、无索引</p>
</li>
<li><p>底层基于哈希表，使用双链表记录添加顺序</p>
</li>
<li><p>默认情况下使用HashSet进行数据去重，如果要求去重而且存取有序，才使用LinkedHashSet</p>
</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ul>
<li>可排序、不重复、无索引</li>
<li>底层基于红黑树实现排序，增删改查性能比较好</li>
</ul>
<h3 id="TreeSet集合自定义排序规则有几种方式"><a href="#TreeSet集合自定义排序规则有几种方式" class="headerlink" title="TreeSet集合自定义排序规则有几种方式"></a>TreeSet集合自定义排序规则有几种方式</h3><ol>
<li>Javabean类实现Comparable接口，指定比较规则</li>
<li>创建集合时，自定义Comparator比较器对象，指定比较规则</li>
</ol>
<p><strong>方法返回值的特点</strong></p>
<ul>
<li>负数：表示当前要添加的元素是小的，存左边</li>
<li>正数：表示当前要添加的元素是大的，存右边</li>
<li>0：表示当前要添加的元素已经存在，舍弃</li>
</ul>
<h3 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h3><ol>
<li>如果想要集合中的元素可重复</li>
</ol>
<ul>
<li>使用ArrayList集合，基于数组（用的最多）</li>
</ul>
<ol start="2">
<li>如果想要集合中的元素可重复，而且当前的增删操作明显多于查询</li>
</ol>
<ul>
<li>用LinkedList集合，基于链表的</li>
</ul>
<ol start="3">
<li>如果想对集合中的元素去重</li>
</ol>
<ul>
<li>用HashSet集合，基于哈希表（用的最多）</li>
</ul>
<ol start="4">
<li>如果想对集合中的元素去重，而且保证存取顺序</li>
</ol>
<ul>
<li>用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet</li>
</ul>
<ol start="5">
<li>如果想对集合中的元素进行排序</li>
</ol>
<ul>
<li>用TreeSet集合，基于红黑树。后续也可以用List集合实现排序</li>
</ul>
<h1 id="双列集合"><a href="#双列集合" class="headerlink" title="双列集合"></a>双列集合</h1><ul>
<li>双列集合一次需要存一对数据，分别为键和值</li>
<li>键不能重复，值可以重复</li>
<li>键和值是一一对应的，每一键只能找到自己对应的值</li>
<li>键+值这个整体我们称之为“键值对”或者“键值对对象”，在Java中叫做“Entry对象”</li>
</ul>
<p>Map</p>
<ul>
<li>HashMap<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li>TreeMap</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map<strong>第一种遍历方法</strong>：获取所有的键值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; strings = map.keySet();</span><br></pre></td></tr></table></figure>

<p>Map<strong>第二种遍历方法</strong>：获取所有的键值对对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br></pre></td></tr></table></figure>

<p>Map<strong>第三种遍历方法</strong>：lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s, String s2)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li>HashMap底层是哈希表结构的</li>
<li>依赖hashCode方法和equals方法保证键的唯一</li>
<li>如果键存储的是自定义对象，需要重写hashCode和equals方法</li>
<li>如果值存储自定义对象，不需要重写hashCode和equals方法</li>
</ul>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>在编译阶段约束操作的数据类型，并进行检查</p>
<h2 id="泛型在集合中的应用"><a href="#泛型在集合中的应用" class="headerlink" title="泛型在集合中的应用"></a>泛型在集合中的应用</h2><ul>
<li>如果没有给集合指定类型，默认认为所有的数据类型都是object类型</li>
<li>此时可以往集合添加任意的数据类型，<strong>但这样做会带来一个坏处</strong>：在获取数据的时候，无法使用他的特有行为</li>
<li>此时就退出了 <strong>泛型</strong>，可以在添加数据的时候就把类型进行统一</li>
<li>泛型的作用是把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来</li>
</ul>
<p> <strong>Java中的泛型是伪泛型</strong></p>
<h2 id="泛型的应用场景"><a href="#泛型的应用场景" class="headerlink" title="泛型的应用场景"></a>泛型的应用场景</h2><ol>
<li>如果我们在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口</li>
<li>如果类型不确定，但是能知道以后智能传递某个继承体系中的，就看缘分使用泛型的通配符</li>
</ol>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ul>
<li><p>红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构</p>
</li>
<li><p><strong>每一个节点可以是红或者黑</strong>；红黑树<strong>不是高度平衡的</strong>，它的平衡是通过<strong>“红黑规则”</strong>进行实现的</p>
</li>
<li><p>红黑树是一颗二叉查找树</p>
</li>
<li><p>但是不是高度平衡的</p>
</li>
<li><p>条件：特有的红黑规则</p>
</li>
</ul>
<h2 id="红黑节点"><a href="#红黑节点" class="headerlink" title="红黑节点"></a>红黑节点</h2><ul>
<li>每一个节点或是红色的，或者是黑色的</li>
<li>根节点必须是黑色的</li>
<li>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点（Nil）是黑色的</li>
<li>如果某一个节点是红色，那么它的子节点必须是黑色（不能出现两个红色节点相连的情况）</li>
<li>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</li>
</ul>
<p><img src="/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9.assets/image-20230225165326438.png" alt="image-20230225165326438"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><ul>
<li><p>可变参数本质上其实是一个数组</p>
</li>
<li><p>作用:在形参中接收多个数据</p>
</li>
<li><p>格式：数据类型…参数名称</p>
<p>举例:int … a</p>
</li>
<li><p>注意事项</p>
<ul>
<li>形参列表中可变参数只有一个</li>
<li>可变参数必须放在形参列表的最后面</li>
</ul>
</li>
</ul>
<h1 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h1><p>创建不可变集合的应用场景</p>
<ul>
<li>如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践</li>
<li>当集合对象被不可信的库调用时，不可变形式是安全的</li>
</ul>
<p><strong>如何创建不可变集合</strong></p>
<ul>
<li>List、Set、Map接口中，都存在of方法可以创建不可变集合</li>
</ul>
<p>三种方式的细节</p>
<ul>
<li>List：直接用</li>
<li>Set：元素不能重复</li>
<li>Map：元素不能重复、键值对的数量最多是10个，超过十个使用ofEntries方法</li>
</ul>
<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p>结合了Lambda表达式，简化集合、数组的操作</p>
<table>
<thead>
<tr>
<th>集合类型</th>
<th>创建方法</th>
<th>方法类型</th>
</tr>
</thead>
<tbody><tr>
<td>单列集合</td>
<td>default Stream<E> stream()</td>
<td>Collection中的默认方法</td>
</tr>
<tr>
<td>双列集合</td>
<td>无</td>
<td>无法直接使用stream流</td>
</tr>
<tr>
<td>数组</td>
<td>public static <T> Stream<T> stream(T[] array)</td>
<td>Arrays工具类中的静态方法</td>
</tr>
<tr>
<td>一堆零散数据</td>
<td>public static<T> Stream<T> of (T…..values)</td>
<td>Stream接口中的静态方法</td>
</tr>
</tbody></table>
<p>Stream接口中的静态方法of的细节</p>
<ul>
<li>方法的形参是一个可变参数，可以传递一堆零散的数据，也可以传递数组</li>
<li>但是数组必须是引用数据类型的，如果传递基本数据类型，是会把数据当做一整个元素放到Stream中</li>
</ul>
<h2 id="Stream的使用步骤"><a href="#Stream的使用步骤" class="headerlink" title="Stream的使用步骤"></a>Stream的使用步骤</h2><ul>
<li>获取Stream流对象</li>
<li>使用中间方法处理数据</li>
<li>使用终结方法处理数据</li>
</ul>
<h2 id="如何获取Stream流对象"><a href="#如何获取Stream流对象" class="headerlink" title="如何获取Stream流对象"></a>如何获取Stream流对象</h2><ul>
<li>单列集合：Collection中的默认方法stream</li>
<li>双列集合：不能直接获取</li>
<li>数组：Arrays工具类中的静态方法stream</li>
<li>一堆零散的数据：Stream接口中的of方法</li>
</ul>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><ul>
<li>中间方法：filter,limit,skip,distinct,concat,map</li>
<li>终结方法: forEach、count、collect</li>
</ul>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>使用的几个条件：</p>
<ol>
<li>引用处需要是函数式接口</li>
<li>被引用的方法需要已经存在</li>
<li>被引用方法的形参和返回值需要跟抽象方法的形参和返回值保持一致</li>
<li>被引用方法的功能需要满足当前的要求</li>
</ol>
<p>方法引用是把已经存在的方法拿过来用，当做函数式接口中抽象方法的方法体</p>
<p>：：是方法引用符</p>
<h2 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h2><p>类名：：静态方法</p>
<h2 id="引用成员方法"><a href="#引用成员方法" class="headerlink" title="引用成员方法"></a>引用成员方法</h2><ol>
<li>对象：：成员方法</li>
<li>this：：成员方法 &#x2F;&#x2F; 不能在静态方法中使用</li>
<li>super：：成员方法 &#x2F;&#x2F;</li>
</ol>
<h2 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h2><p>类名：：new</p>
<h2 id="使用类名引用成员方法"><a href="#使用类名引用成员方法" class="headerlink" title="使用类名引用成员方法"></a>使用类名引用成员方法</h2><p>类名：：成员方法</p>
<p>不能引用所有类中的成员方法</p>
<p>如果抽象方法的第一个参数是A类型的</p>
<p>只能引用A类中的方法</p>
<h2 id="引用数组的构造方法"><a href="#引用数组的构造方法" class="headerlink" title="引用数组的构造方法"></a>引用数组的构造方法</h2><p>数据类型[] :: new</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><img src="https://cdn.jsdelivr.net/gh/LYHazard/blog.img/202303022129958.png" alt="image-20230302212937588"></p>
<h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><table>
<thead>
<tr>
<th>构造方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>public File(String pathname)</td>
<td>根据文件路径创建文件对象</td>
</tr>
<tr>
<td>public File(String parent,String child)</td>
<td>根据父路径名字符串和子路径名字符串创建文件对象</td>
</tr>
<tr>
<td>public File(File parent, String child)</td>
<td>根据父路径对应文件对象和子路径名字符串创建文件对象</td>
</tr>
</tbody></table>
<ol>
<li>File表示什么：File对象表示路径，可以是文件、也可以是文件夹 这个路径可以是存在的，也可以是不存在的</li>
<li>绝对路径和相对路径是什么意思：</li>
</ol>
<ul>
<li>绝对路径是带盘符的。</li>
<li>相对路径是不带盘符的，默认到当前项目下去找</li>
</ul>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>IO流中，是程序在读，程序在写。</p>
<p>存储和读取数据的解决方案</p>
<p>IO流的作用： 用于读写数据（本地文件，网络）</p>
<p><strong>流的方向</strong>：</p>
<p>IO流</p>
<ul>
<li>输入流  读取</li>
<li>输出流  写出</li>
</ul>
<p><strong>操作文件类型</strong>：</p>
<ul>
<li>字节流：所有类型的文件</li>
<li>字符流：只能操作纯文本文件</li>
</ul>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h3><ol>
<li>创建字节输出流对象</li>
</ol>
<ul>
<li>细节1：参数是字符串表示的路径或者是file对象也可以</li>
<li>细节2：如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的</li>
<li>细节3：如果文件已经存在，则会清空文件</li>
</ul>
<ol start="2">
<li>写数据</li>
</ol>
<ul>
<li>细节1：write方法的参数是整数，但是实际上写到本地文件中的是整数在ASCII上对应的字符</li>
</ul>
<ol start="3">
<li>释放资源</li>
</ol>
<ul>
<li>每个流都要释放资源</li>
</ul>
<h3 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h3><ol>
<li><p>创建字节输入流对象</p>
<p>细节1：如果文件不存在，就直接报错</p>
</li>
<li><p>读取数据</p>
</li>
</ol>
<ul>
<li>一次读一个字节，读出来的是数据在ASCII上对应的数字</li>
<li>读到文件末尾了，read方法返回-1</li>
</ul>
<ol start="3">
<li>释放资源</li>
<li>不能在同一个循环中反复调用，因为每执行一次read()方法就会移动一次指针，所以需要一个代码赋值</li>
</ol>
<p>如果读取大文件可以使用 <strong>字节数组的方式读取</strong></p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>底层是字节流</p>
<h3 id="FileRead"><a href="#FileRead" class="headerlink" title="FileRead"></a>FileRead</h3><p>read方法细节: </p>
<ul>
<li>read():默认是一个字节一个字节读取的，如果遇到中文就会一次读取多个</li>
<li>在读取之后，方法的底层还会进行解码并转成十进制，最终把这个十进制作为返回值，这个十进制的数据也表示在字符集上的数字</li>
</ul>
<h3 id="字符流原理解析"><a href="#字符流原理解析" class="headerlink" title="字符流原理解析"></a>字符流原理解析</h3><h3 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h3><ol>
<li>创建字符输入流对象</li>
</ol>
<p>  底层：关联文件，并创建缓冲区（长度为8192的字节数组）</p>
<ol start="2">
<li>读取数据</li>
</ol>
<p>底层：</p>
<ol>
<li><p>判断缓冲区中是否有数据可以读取</p>
</li>
<li><p><strong>缓冲区中没有数据：</strong>就从文件中获取数据，装到缓冲区中，每次尽可能装满缓冲区，如果文件中也没有数据了，返回-1</p>
</li>
<li><p><strong>缓冲区中有数据</strong>：就从缓冲区中读取。（缓冲区大小为8192）</p>
<p>空参的read方法：一次读取一个字节，遇到中文一次读取多个字节，把字节解码并转成十进制返回。</p>
<p>有参的read方法：把读取字节，解码，强转三步合并，强转之后的字符放到数组中</p>
</li>
</ol>
<p><strong>创建字符输入流既往缓冲区中加入数据</strong></p>
<h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><ul>
<li>缓冲流自带长度为8192的缓冲区</li>
<li>可以显著提高字节流的读写性能</li>
<li>对于字符流提升不明显，对于字符缓冲流而言关键的是两个特有方法</li>
</ul>
<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>构造方法</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>BufferedInputStream(InputStream in)</td>
<td>字节输入流</td>
</tr>
<tr>
<td>BufferedInputStream(OutputStream out)</td>
<td>字节输出流</td>
</tr>
</tbody></table>
<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>构造方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BufferedReader(Reader r)</td>
<td>把基本流变成高级流</td>
</tr>
<tr>
<td>public BufferedWriter(Writer w)</td>
<td>把基本流变成高级流</td>
</tr>
</tbody></table>
<h3 id="字符缓冲流特有方法"><a href="#字符缓冲流特有方法" class="headerlink" title="字符缓冲流特有方法"></a>字符缓冲流特有方法</h3><table>
<thead>
<tr>
<th>字符缓冲流输入流特有方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String readLine()</td>
<td align="left">读取一行数据，如果没有数据可读了，会返回null</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>字符缓冲流输出流特有方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void newLine()</td>
<td align="left">跨平台的换行</td>
</tr>
</tbody></table>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><ul>
<li>字符转换输入流：inputStreamReader</li>
<li>字符转换输出流：OutputStreamWriter</li>
</ul>
<p>转换流的作用：</p>
<ul>
<li>指定字符集读写数据（jdk11之后淘汰了）</li>
<li>字节流想要使用字符流中的方法了</li>
</ul>
<h2 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h2><ol>
<li>需要实现Serializable接口</li>
<li>序列化流写到文件中的数据是不可修改的，一旦修改就无法再次读回来了</li>
<li>序列化对象后，修改了Javabean类，再次反序列化，会出问题，抛出InvalidClassException异常，给javabean类加上SerialVersionUID（序列号）就不会报错，Idea上有自动生成的配置</li>
<li>如果某个变量不想被序列化，那么给此变量加上transit关键字</li>
<li>序列化多个对象的时候要先把对象放入集合当中，读取时直接读取集合</li>
</ol>
<h3 id="对象操作输出流"><a href="#对象操作输出流" class="headerlink" title="对象操作输出流"></a>对象操作输出流</h3><p>可以把java中的对象写到本地文件中</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ObjectOutputStream(OutputStream out)</td>
<td>把基本流包装成高级流</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public final void writeObject(Object obj)</td>
<td>把对象序列化（写出）到文件中去</td>
</tr>
</tbody></table>
<h2 id="对象操作输入流"><a href="#对象操作输入流" class="headerlink" title="对象操作输入流"></a>对象操作输入流</h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ObjectInputStream(InputStream out)</td>
<td>把基本流变成高级流</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Object readObject</td>
<td>把序列化到本地文件中的对象，读取到程序中来</td>
</tr>
</tbody></table>
<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>分类：打印流是指，PrintStream，PrintWrite两个类</p>
<p>特点1：打印流致操作文件的目的地，不操作数据源</p>
<p>特点2：特有的写出方法可以实现，数据原样写出</p>
<p>特点3: 特有的写出方法，可以实现自动刷新，自动换行</p>
<ul>
<li>打印流不操作数据源，只能操作目的地</li>
<li>字节打印流：默认自动刷新，特有的println自动换行</li>
<li>字符打印流: 自动刷新需要开启，特有的println自动换行</li>
</ul>
<h3 id="字节打印流"><a href="#字节打印流" class="headerlink" title="字节打印流"></a>字节打印流</h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public PrintStream(OutputStream&#x2F;File&#x2F;String)</td>
<td>关联字节输出流&#x2F;文件&#x2F;文件路径</td>
</tr>
<tr>
<td>public PrintStream（String filename，Charset charset）</td>
<td>指定字符编码</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int b)</td>
<td>常规方法，规则跟之前一样，将指定的字节写出</td>
</tr>
<tr>
<td>void println(XXX xx )</td>
<td><strong>特有方法：</strong>打印任意数据，自动刷新，自动换行</td>
</tr>
<tr>
<td>void print(XXX xx )</td>
<td><strong>特有方法：</strong>打印任意数据，不换行</td>
</tr>
<tr>
<td>void printf（String format，Object….args）</td>
<td><strong>特有方法：</strong>带有占位符的打印语句，不换行</td>
</tr>
</tbody></table>
<h3 id="字符打印流"><a href="#字符打印流" class="headerlink" title="字符打印流"></a>字符打印流</h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public PrintWriter(OutputStream&#x2F;File&#x2F;String)</td>
<td>关联字节输出流&#x2F;文件&#x2F;文件路径</td>
</tr>
<tr>
<td>public PrintWriter（String filename，Charset charset）</td>
<td>指定字符编码</td>
</tr>
</tbody></table>
<h2 id="转换流-1"><a href="#转换流-1" class="headerlink" title="转换流"></a>转换流</h2><p>把字节流转换成字符流</p>
<p>InputStreamReader</p>
<p>OutputStreamWriter</p>
<h2 id="解压缩流"><a href="#解压缩流" class="headerlink" title="解压缩流"></a>解压缩流</h2><h3 id="压缩流"><a href="#压缩流" class="headerlink" title="压缩流"></a>压缩流</h3><p>压缩的本质：把每一个（文件&#x2F;文件夹）看成是ZipEntry对象放到压缩包中</p>
<p>解压的本质：把压缩包中的每一个文件或者文件夹(Entry)都读取出来，按照层级拷贝到目的地中</p>
<h1 id="第三方jar包的使用"><a href="#第三方jar包的使用" class="headerlink" title="第三方jar包的使用"></a>第三方jar包的使用</h1><ol>
<li>在项目中创建一个文件夹lib</li>
<li>将jar包复制黏贴到lib文件夹当中</li>
<li>右键点击jar包，选择Add as Library -&gt; 点击OK</li>
<li>在类中导包使用</li>
</ol>
<h1 id="配置文件properties"><a href="#配置文件properties" class="headerlink" title="配置文件properties"></a>配置文件properties</h1><ul>
<li>把软件的设置永久化存储</li>
<li>如果需要修改参数，不需要改动代码，直接修改配置文件就可以</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>在同一时刻，有多个指令在单个cpu上交替执行</p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>在同一时刻，有多个指令在多个CPU上同时执行</p>
<h2 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h2><table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>继承Thread类</td>
<td>编程比较简单，可以直接使用Thread类中的方法</td>
<td>可拓展性差，不能再继承其他的类</td>
</tr>
<tr>
<td>实现Runnable接口</td>
<td>拓展性强，实现该接口的同时还可以继承其他的类</td>
<td>编程相对复杂，不能直接使用Thread类中的方法</td>
</tr>
<tr>
<td>实现Callable接口</td>
<td>拓展性强，实现该接口的同时还可以继承其他的类</td>
<td>可以获取线程中获得的数据</td>
</tr>
</tbody></table>
<h2 id="多线程的生命周期"><a href="#多线程的生命周期" class="headerlink" title="多线程的生命周期"></a>多线程的生命周期</h2><ol>
<li>在调用.start()方法后线程将转为就绪态</li>
<li>在就绪态的线程抢占到cpu资源后会转为执行态</li>
<li>执行态的线程丢失掉资源后会转为就绪态</li>
<li>执行态的线程在执行sleep方法后会转为阻塞态</li>
<li>执行态的线程执行完run()方法后会转换成死亡态</li>
</ol>
<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><ol>
<li>在操作共享数据时，会因为多个线程的抢占资源导致共享数据被多个线程同时执行，导致结果出现问题</li>
<li>用syncronized关键字添加上一个锁对象，在此关键字范围中的代码一次只能有一个线程进行执行</li>
</ol>
<h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h2><p>实现方式1，提供中间人</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.Thread.producer_consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1. 循环</span></span><br><span class="line"><span class="comment">         * 2. 同步代码块</span></span><br><span class="line"><span class="comment">         * 3. 判断共享数据是否到了末尾（到了末尾）</span></span><br><span class="line"><span class="comment">         * 4. 判断共享数据是否到了末尾（没有到末尾，执行核心逻辑）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Mediator.lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Mediator.count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//判断有无余量</span></span><br><span class="line">                    <span class="keyword">if</span> (Mediator.foodFlag == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//没有了，进行等待</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Mediator.lock.wait();<span class="comment">//让当前线程和锁进行绑定</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果有，就使用</span></span><br><span class="line">                        Mediator.count--;</span><br><span class="line">                        System.out.println(<span class="string">&quot;需要的粮食还剩&quot;</span> + Mediator.count);</span><br><span class="line">                        <span class="comment">//使用完后唤醒生产者生产</span></span><br><span class="line">                        Mediator.lock.notifyAll();</span><br><span class="line">                        <span class="comment">//修改存粮状态</span></span><br><span class="line">                        Mediator.foodFlag = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.Thread.producer_consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  作用：控制生产者和消费者的执行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="comment">//定义一个变量判断是否有存粮 0：表示没有 1：表示有</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">foodFlag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一下需要的粮食的总个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义锁对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.Thread.producer_consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1. 循环</span></span><br><span class="line"><span class="comment">         * 2. 同步代码块</span></span><br><span class="line"><span class="comment">         * 3. 判断共享数据是否到了末尾（到了末尾）</span></span><br><span class="line"><span class="comment">         * 4. 判断共享数据是否到了末尾（没有到末尾，执行核心逻辑）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Mediator.lock)&#123;</span><br><span class="line">                <span class="comment">//当消费者的需求为0时就不用生产了</span></span><br><span class="line">                <span class="keyword">if</span> (Mediator.count == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果桌面上还有产物,则线程等待</span></span><br><span class="line">                    <span class="keyword">if</span> (Mediator.foodFlag == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Mediator.lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;<span class="comment">//没有产物则线程开启，并生产</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;生产者开始生产&quot;</span>);</span><br><span class="line">                        Mediator.foodFlag =<span class="number">1</span>;</span><br><span class="line">                        Mediator.lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现方式二-阻塞队列"><a href="#实现方式二-阻塞队列" class="headerlink" title="实现方式二 阻塞队列"></a><strong>实现方式二</strong> 阻塞队列</h3><p><img src="/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9.assets/image-20230314143330999-16787756136801.png" alt="image-20230314143330999"></p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>新建状态（NEW） –》 创建线程对象</p>
<p>就绪状态（RUNNABLE） –》start方法</p>
<p>阻塞状态（BLOCKED） –》无法获得锁对象</p>
<p>等待状态（WAITING） –》wait方法</p>
<p>计时等待（TIMED_WAITING） –》sleep方法</p>
<p>结束状态（TERMINATED） –》全部代码运行完毕</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/03/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9/" data-id="clf99j8ra000gokm67at28fge" data-title="java 常识内容" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          设计模式
        
      </div>
    </a>
  
  
    <a href="/2022/12/20/java-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">java 内存相关</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E5%B8%B8%E5%9C%A8Android-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E4%BD%86%E5%8F%88%E8%A6%81%E8%A7%84%E9%81%BF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E4%B8%80%E8%88%AC%E9%83%BD%E4%BC%9A%E9%87%87%E7%94%A8-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB-%E5%BC%B1%E5%BC%95%E7%94%A8-%E7%9A%84%E6%96%B9%E5%BC%8F/" rel="tag">通常在Android 开发中如果要使用内部类，但又要规避内存泄露，一般都会采用 静态内部类 + 弱引用 的方式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E8%BF%87%E8%A7%A3%E8%80%A6%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E8%AE%A2%E9%98%85%E8%80%85%E7%AE%80%E5%8C%96Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/" rel="tag">通过解耦发布者和订阅者简化Android事件传递</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E9%80%9A%E5%B8%B8%E5%9C%A8Android-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E4%BD%86%E5%8F%88%E8%A6%81%E8%A7%84%E9%81%BF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E4%B8%80%E8%88%AC%E9%83%BD%E4%BC%9A%E9%87%87%E7%94%A8-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB-%E5%BC%B1%E5%BC%95%E7%94%A8-%E7%9A%84%E6%96%B9%E5%BC%8F/" style="font-size: 10px;">通常在Android 开发中如果要使用内部类，但又要规避内存泄露，一般都会采用 静态内部类 + 弱引用 的方式</a> <a href="/tags/%E9%80%9A%E8%BF%87%E8%A7%A3%E8%80%A6%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E8%AE%A2%E9%98%85%E8%80%85%E7%AE%80%E5%8C%96Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/" style="font-size: 10px;">通过解耦发布者和订阅者简化Android事件传递</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/09/commons-io%E6%95%B4%E7%90%86%E7%9A%84%E6%96%87%E6%A1%A3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2023/01/03/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9/">java 常识内容</a>
          </li>
        
          <li>
            <a href="/2022/12/20/java-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/">java 内存相关</a>
          </li>
        
          <li>
            <a href="/2022/12/10/%E6%BA%90%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/">源码、补码、反码</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>