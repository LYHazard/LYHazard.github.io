<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-commons-io整理的文档" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/03/09/commons-io%E6%95%B4%E7%90%86%E7%9A%84%E6%96%87%E6%A1%A3/" class="article-date">
  <time class="dt-published" datetime="2023-03-09T13:47:54.413Z" itemprop="datePublished">2023-03-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1，IOUtils（数据相关）"><a href="#1，IOUtils（数据相关）" class="headerlink" title="1，IOUtils（数据相关）"></a>1，IOUtils（数据相关）</h1><h3 id="拷贝方法："><a href="#拷贝方法：" class="headerlink" title="拷贝方法："></a>拷贝方法：</h3><p>copy方法有多个重载方法，满足不同的输入输出流</p>
<p>IOUtils.copy(InputStream input, OutputStream output)</p>
<p>IOUtils.copy(InputStream input, OutputStream output, int bufferSize)&#x2F;&#x2F;可指定缓冲区大小</p>
<p>IOUtils.copy(InputStream input, Writer output, String inputEncoding)&#x2F;&#x2F;可指定输入流的编码表</p>
<p>IOUtils.copy(Reader input, Writer output)</p>
<p>IOUtils.copy(Reader input, OutputStream output, String outputEncoding)&#x2F;&#x2F;可指定输出流的编码表</p>
<h3 id="拷贝大文件的方法："><a href="#拷贝大文件的方法：" class="headerlink" title="拷贝大文件的方法："></a>拷贝大文件的方法：</h3><p>&#x2F;&#x2F; 这个方法适合拷贝较大的数据流，比如2G以上</p>
<p>IOUtils.copyLarge(Reader input, Writer output) &#x2F;&#x2F; 默认会用1024*4的buffer来读取</p>
<p>IOUtils.copyLarge(Reader input, Writer output, char[] buffer)&#x2F;&#x2F;可指定缓冲区大小</p>
<p> </p>
<h3 id="将输入流转换成字符串"><a href="#将输入流转换成字符串" class="headerlink" title="将输入流转换成字符串"></a>将输入流转换成字符串</h3><p>IOUtils.toString(Reader input)</p>
<p>IOUtils.toString(byte[] input, String encoding)</p>
<p>IOUtils.toString(InputStream input, Charset encoding)</p>
<p>IOUtils.toString(InputStream input, String encoding)</p>
<p>IOUtils.toString(URI uri, String encoding)</p>
<p>IOUtils.toString(URL url, String encoding)</p>
<p> </p>
<h3 id="将输入流转换成字符数组"><a href="#将输入流转换成字符数组" class="headerlink" title="将输入流转换成字符数组"></a>将输入流转换成字符数组</h3><p>IOUtils.toByteArray(InputStream input)</p>
<p>IOUtils.toByteArray(InputStream input, int size)</p>
<p>IOUtils.toByteArray(URI uri)</p>
<p>IOUtils.toByteArray(URL url)</p>
<p>IOUtils.toByteArray(URLConnection urlConn)</p>
<p>IOUtils.toByteArray(Reader input, String encoding)</p>
<p> </p>
<h3 id="字符串读写"><a href="#字符串读写" class="headerlink" title="字符串读写"></a>字符串读写</h3><p>IOUtils.readLines(Reader input)</p>
<p>IOUtils.readLines(InputStream input, Charset encoding)</p>
<p>IOUtils.readLines(InputStream input, String encoding)</p>
<p>IOUtils.writeLines(Collection&lt;?&gt; lines, String lineEnding, Writer writer)</p>
<p>IOUtils.writeLines(Collection&lt;?&gt; lines, String lineEnding, OutputStream output, Charset encoding)</p>
<p>IOUtils.writeLines(Collection&lt;?&gt; lines, String lineEnding, OutputStream output, String encoding)</p>
<h3 id="从一个流中读取内容"><a href="#从一个流中读取内容" class="headerlink" title="从一个流中读取内容"></a>从一个流中读取内容</h3><p>IOUtils.read(InputStream input, byte[] buffer)</p>
<p>IOUtils.read(InputStream input, byte[] buffer, int offset, int length) IOUtils.read(Reader input, char[] buffer)</p>
<p>IOUtils.read(Reader input, char[] buffer, int offset, int length)</p>
<h3 id="把数据写入到输出流中"><a href="#把数据写入到输出流中" class="headerlink" title="把数据写入到输出流中"></a>把数据写入到输出流中</h3><p>IOUtils.write(byte[] data, OutputStream output)</p>
<p>IOUtils.write(byte[] data, Writer output, Charset encoding)</p>
<p>IOUtils.write(byte[] data, Writer output, String encoding)</p>
<p>IOUtils.write(char[] data, Writer output)</p>
<p>IOUtils.write(char[] data, OutputStream output, Charset encoding)</p>
<p>IOUtils.write(char[] data, OutputStream output, String encoding)</p>
<p>IOUtils.write(String data, Writer output)</p>
<p>IOUtils.write(CharSequence data, Writer output)</p>
<p> </p>
<h3 id="从一个流中读取内容，如果读取的长度不够，就会抛出异常"><a href="#从一个流中读取内容，如果读取的长度不够，就会抛出异常" class="headerlink" title="从一个流中读取内容，如果读取的长度不够，就会抛出异常"></a>从一个流中读取内容，如果读取的长度不够，就会抛出异常</h3><p>IOUtils.readFully(InputStream input, int length)</p>
<p>IOUtils.readFully(InputStream input, byte[] buffer)</p>
<p>IOUtils.readFully(InputStream input, byte[] buffer, int offset, int length) IOUtils.readFully(Reader input, char[] buffer)</p>
<p>IOUtils.readFully(Reader input, char[] buffer, int offset, int length)</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>IOUtils.contentEquals(InputStream input1, InputStream input2) &#x2F;&#x2F; 比较两个流是否相等</p>
<p>IOUtils.contentEquals(Reader input1, Reader input2)</p>
<p>IOUtils.contentEqualsIgnoreEOL(Reader input1, Reader input2) &#x2F;&#x2F; 比较两个流，忽略换行符</p>
<p> </p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>IOUtils.skip(InputStream input, long toSkip) &#x2F;&#x2F; 跳过指定长度的流</p>
<p>IOUtils.skip(Reader input, long toSkip)</p>
<p>IOUtils.skipFully(InputStream input, long toSkip) &#x2F;&#x2F; 如果忽略的长度大于现有的长度，就会抛出异常</p>
<p>IOUtils.skipFully(Reader input, long toSkip)</p>
<p> </p>
<h1 id="2，FileUtils（文件-x2F-文件夹相关）"><a href="#2，FileUtils（文件-x2F-文件夹相关）" class="headerlink" title="2，FileUtils（文件&#x2F;文件夹相关）"></a>2，FileUtils（文件&#x2F;文件夹相关）</h1><h3 id="复制文件夹"><a href="#复制文件夹" class="headerlink" title="复制文件夹"></a>复制文件夹</h3><p>FileUtils.copyDirectory(File srcDir, File destDir) &#x2F;&#x2F; 复制文件夹（文件夹里面的文件内容也会复制）</p>
<p>FileUtils.copyDirectory(File srcDir, File destDir, FileFilter filter) &#x2F;&#x2F; 复制文件夹，带有文件过滤功能</p>
<p>FileUtils.copyDirectoryToDirectory(File srcDir, File destDir) &#x2F;&#x2F; 以子目录的形式将文件夹复制到到另一个文件夹下</p>
<p> </p>
<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>FileUtils.copyFile(File srcFile, File destFile) &#x2F;&#x2F; 复制文件</p>
<p>FileUtils.copyFile(File input, OutputStream output) &#x2F;&#x2F; 复制文件到输出流</p>
<p>FileUtils.copyFileToDirectory(File srcFile, File destDir) &#x2F;&#x2F; 复制文件到一个指定的目录</p>
<p>FileUtils.copyInputStreamToFile(InputStream source, File destination) &#x2F;&#x2F; 把输入流里面的内容复制到指定文件</p>
<p>FileUtils.copyURLToFile(URL source, File destination) &#x2F;&#x2F; 把URL 里面内容复制到文件(可以下载文件)</p>
<p>FileUtils.copyURLToFile(URL source, File destination, int connectionTimeout, int readTimeout)</p>
<p> </p>
<h3 id="把字符串写入文件"><a href="#把字符串写入文件" class="headerlink" title="把字符串写入文件"></a>把字符串写入文件</h3><p>FileUtils.writeStringToFile(File file, String data, String encoding)</p>
<p>FileUtils.writeStringToFile(File file, String data, String encoding, boolean append)</p>
<h3 id="把字节数组写入文件"><a href="#把字节数组写入文件" class="headerlink" title="把字节数组写入文件"></a>把字节数组写入文件</h3><p>FileUtils.writeByteArrayToFile(File file, byte[] data)</p>
<p>FileUtils.writeByteArrayToFile(File file, byte[] data, boolean append) FileUtils.writeByteArrayToFile(File file, byte[] data, int off, int len) FileUtils.writeByteArrayToFile(File file, byte[] data, int off, int len, boolean append)</p>
<h3 id="把集合里面的内容写入文件"><a href="#把集合里面的内容写入文件" class="headerlink" title="把集合里面的内容写入文件"></a>把集合里面的内容写入文件</h3><p>&#x2F;&#x2F; encoding：文件编码，lineEnding：每行以什么结尾</p>
<p>FileUtils.writeLines(File file, Collection&lt;?&gt; lines)</p>
<p>FileUtils.writeLines(File file, Collection&lt;?&gt; lines, boolean append)</p>
<p>FileUtils.writeLines(File file, Collection&lt;?&gt; lines, String lineEnding)</p>
<p>FileUtils.writeLines(File file, Collection&lt;?&gt; lines, String lineEnding, boolean append)</p>
<p>FileUtils.writeLines(File file, String encoding, Collection&lt;?&gt; lines)</p>
<p>FileUtils.writeLines(File file, String encoding, Collection&lt;?&gt; lines, boolean append)</p>
<p>FileUtils.writeLines(File file, String encoding, Collection&lt;?&gt; lines, String lineEnding)</p>
<p>FileUtils.writeLines(File file, String encoding, Collection&lt;?&gt; lines, String lineEnding, boolean append)</p>
<h3 id="往文件里面写内容"><a href="#往文件里面写内容" class="headerlink" title="往文件里面写内容"></a>往文件里面写内容</h3><p>FileUtils.write(File file, CharSequence data, Charset encoding)</p>
<p>FileUtils.write(File file, CharSequence data, Charset encoding, boolean append)</p>
<p>FileUtils.write(File file, CharSequence data, String encoding)</p>
<p>FileUtils.write(File file, CharSequence data, String encoding, boolean append)</p>
<p> </p>
<h3 id="文件移动"><a href="#文件移动" class="headerlink" title="文件移动"></a>文件移动</h3><p>FileUtils.moveDirectory(File srcDir, File destDir) &#x2F;&#x2F; 文件夹在内的所有文件都将移动FileUtils.moveDirectoryToDirectory(File src, File destDir, boolean createDestDir) &#x2F;&#x2F; 以子文件夹的形式移动到另外一个文件下</p>
<p>FileUtils.moveFile(File srcFile, File destFile) &#x2F;&#x2F; 移动文件</p>
<p>FileUtils.moveFileToDirectory(File srcFile, File destDir, boolean createDestDir) &#x2F;&#x2F; 以子文件的形式移动到另外一个文件夹下</p>
<p>FileUtils.moveToDirectory(File src, File destDir, boolean createDestDir) &#x2F;&#x2F; 移动文件或者目录到指定的文件夹内</p>
<p> </p>
<h3 id="清空和删除文件夹"><a href="#清空和删除文件夹" class="headerlink" title="清空和删除文件夹"></a>清空和删除文件夹</h3><p>FileUtils.deleteDirectory(File directory) &#x2F;&#x2F; 删除文件夹，包括文件夹和文件夹里面所有的文件</p>
<p>FileUtils.cleanDirectory(File directory) &#x2F;&#x2F; 清空文件夹里面的所有的内容</p>
<p>FileUtils.forceDelete(File file) &#x2F;&#x2F; 删除，会抛出异常</p>
<p>FileUtils.deleteQuietly(File file) &#x2F;&#x2F; 删除，不会抛出异常</p>
<p> </p>
<h3 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h3><p>FileUtils.forceMkdir(File directory) &#x2F;&#x2F; 创建文件夹(可创建多级)</p>
<p>FileUtils.forceMkdirParent(File file) &#x2F;&#x2F; 创建文件的父级目录</p>
<p> </p>
<h3 id="获取文件输入-x2F-输出流"><a href="#获取文件输入-x2F-输出流" class="headerlink" title="获取文件输入&#x2F;输出流"></a>获取文件输入&#x2F;输出流</h3><p>FileUtils.openInputStream(File file)</p>
<p>FileUtils.openOutputStream(File file)</p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>FileUtils.readFileToByteArray(File file) &#x2F;&#x2F; 把文件读取到字节数组</p>
<p>FileUtils.readFileToString(File file, Charset encoding) &#x2F;&#x2F; 把文件读取成字符串</p>
<p>FileUtils.readFileToString(File file, String encoding)</p>
<p>FileUtils.readLines(File file, Charset encoding) &#x2F;&#x2F; 把文件读取成字符串集合</p>
<p>FileUtils.readLines(File file, String encoding)</p>
<p> </p>
<h3 id="测试两个文件的修改时间"><a href="#测试两个文件的修改时间" class="headerlink" title="测试两个文件的修改时间"></a>测试两个文件的修改时间</h3><p>FileUtils.isFileNewer(File file, Date date)</p>
<p>FileUtils.isFileNewer(File file, File reference)</p>
<p>FileUtils.isFileNewer(File file, long timeMillis)</p>
<p>FileUtils.isFileOlder(File file, Date date)</p>
<p>FileUtils.isFileOlder(File file, File reference)</p>
<p>FileUtils.isFileOlder(File file, long timeMillis)</p>
<p> </p>
<p> </p>
<h3 id="文件-x2F-文件夹的迭代"><a href="#文件-x2F-文件夹的迭代" class="headerlink" title="文件&#x2F;文件夹的迭代"></a>文件&#x2F;文件夹的迭代</h3><p>FileUtils.iterateFiles(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter)</p>
<p>FileUtils.iterateFiles(File directory, String[] extensions, boolean recursive)</p>
<p>FileUtils.iterateFilesAndDirs(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter)</p>
<p>FileUtils.lineIterator(File file)</p>
<p>FileUtils.lineIterator(File file, String encoding)</p>
<p> </p>
<p>FileUtils.listFiles(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter)</p>
<p>FileUtils.listFiles(File directory, String[] extensions, boolean recursive)</p>
<p>FileUtils.listFilesAndDirs(File directory, IOFileFilter fileFilter, IOFileFilter dirFilter)</p>
<p> </p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>FileUtils.isSymlink(File file) &#x2F;&#x2F; 判断是否是符号链接</p>
<p>FileUtils.directoryContains(File directory, File child) &#x2F;&#x2F; 判断文件夹内是否包含某个文件或者文件夹</p>
<p> FileUtils.sizeOf(File file) &#x2F;&#x2F; 获取文件或者文件夹的大小</p>
<p>FileUtils.getTempDirectory()&#x2F;&#x2F; 获取临时目录文件</p>
<p>FileUtils.getTempDirectoryPath()&#x2F;&#x2F; 获取临时目录路径</p>
<p>FileUtils.getUserDirectory()&#x2F;&#x2F; 获取用户目录文件</p>
<p>FileUtils.getUserDirectoryPath()&#x2F;&#x2F; 获取用户目录路径</p>
<p>FileUtils.touch(File file) &#x2F;&#x2F; 创建文件</p>
<p>FileUtils.contentEquals(File file1, File file2) &#x2F;&#x2F; 比较两个文件内容是否相同</p>
<h1 id="FilenameUtils（文件名-x2F-后缀名相关）"><a href="#FilenameUtils（文件名-x2F-后缀名相关）" class="headerlink" title="FilenameUtils（文件名&#x2F;后缀名相关）"></a>FilenameUtils（文件名&#x2F;后缀名相关）</h1><p>FilenameUtils.concat(String basePath, String fullFilenameToAdd) &#x2F;&#x2F; 合并目录和文件名为文件全路径</p>
<p>FilenameUtils.getBaseName(String filename) &#x2F;&#x2F; 去除目录和后缀后的文件名</p>
<p>FilenameUtils.getExtension(String filename) &#x2F;&#x2F; 获取文件的后缀</p>
<p>FilenameUtils.getFullPath(String filename) &#x2F;&#x2F; 获取文件的目录</p>
<p>FilenameUtils.getName(String filename) &#x2F;&#x2F; 获取文件名</p>
<p>FilenameUtils.getPath(String filename) &#x2F;&#x2F; 去除盘符后的路径</p>
<p>FilenameUtils.getPrefix(String filename) &#x2F;&#x2F; 盘符</p>
<p>FilenameUtils.indexOfExtension(String filename) &#x2F;&#x2F; 获取最后一个.的位置</p>
<p>FilenameUtils.indexOfLastSeparator(String filename) &#x2F;&#x2F; 获取最后一个&#x2F;的位置</p>
<p>FilenameUtils.normalize(String filename) &#x2F;&#x2F; 获取当前系统格式化路径</p>
<p>FilenameUtils.removeExtension(String filename) &#x2F;&#x2F; 移除文件的扩展名</p>
<p>FilenameUtils.separatorsToSystem(String path) &#x2F;&#x2F; 转换分隔符为当前系统分隔符</p>
<p>FilenameUtils.separatorsToUnix(String path) &#x2F;&#x2F; 转换分隔符为linux系统分隔符</p>
<p>FilenameUtils.separatorsToWindows(String path) &#x2F;&#x2F; 转换分隔符为windows系统分隔符</p>
<p>FilenameUtils.equals(String filename1, String filename2) &#x2F;&#x2F; 判断文件路径是否相同，非格式化</p>
<p>FilenameUtils.equalsNormalized(String filename1, String filename2) &#x2F;&#x2F; 判断文件路径是否相同，格式化</p>
<p>FilenameUtils.directoryContains(String canonicalParent, String canonicalChild) &#x2F;&#x2F; 判断目录下是否包含指定文件或目录</p>
<p>FilenameUtils.isExtension(String filename, String extension) &#x2F;&#x2F; 判断文件扩展名是否包含在指定集合(数组、字符串)中</p>
<p>FilenameUtils.wildcardMatch(String filename, String wildcardMatcher) &#x2F;&#x2F; 判断文件扩展名是否和指定规则匹配	</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/09/commons-io%E6%95%B4%E7%90%86%E7%9A%84%E6%96%87%E6%A1%A3/" data-id="clf99j8r60009okm6fqhdg2rk" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-01-30T08:26:30.000Z" itemprop="datePublished">2023-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h1><ol>
<li>当一个接口中抽象方法过多，但是我只要使用其中一部分的时候，就可以使用适配器模式</li>
<li>书写步骤</li>
</ol>
<ul>
<li>编写中间类XXXAdapter，实现对应的接口</li>
<li>对接口中的抽象方法进行空实现</li>
<li>让真正的实现类继承中间类，并重写需要用的方法</li>
<li>为避免其他类创建适配器类的对象，中间的适配器类用abstract进行修饰</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="clf99j8rb000iokm68ca7apo6" data-title="设计模式" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java-常识内容" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/03/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9/" class="article-date">
  <time class="dt-published" datetime="2023-01-03T09:46:20.000Z" itemprop="datePublished">2023-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/03/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9/">java 常识内容</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="“-x3D-”相关"><a href="#“-x3D-”相关" class="headerlink" title="“&#x3D;”相关"></a>“&#x3D;”相关</h1><p>在数组类型用“&#x3D;” 进行赋值时 此时赋值的内容是地址，其中一个数组的内容改变，另一个的内容也随之改变</p>
<h1 id="“-x3D-x3D-”符号的相关"><a href="#“-x3D-x3D-”符号的相关" class="headerlink" title="“&#x3D;&#x3D;”符号的相关"></a>“&#x3D;&#x3D;”符号的相关</h1><p>在比较基本数据类型时”&#x3D;&#x3D;”比较的是数据值</p>
<p>在比较引用数据类型时“&#x3D;&#x3D;”比较的是地址值</p>
<h1 id="字符串相关的底层原理"><a href="#字符串相关的底层原理" class="headerlink" title="字符串相关的底层原理"></a>字符串相关的底层原理</h1><h2 id="字符串存储的内存原理"><a href="#字符串存储的内存原理" class="headerlink" title="字符串存储的内存原理"></a>字符串存储的内存原理</h2><ul>
<li>直接赋值会复用字符串常量池中的</li>
<li>new出来的不会复用，而是开辟一个新的空间</li>
</ul>
<h2 id="字符串拼接的底层原理"><a href="#字符串拼接的底层原理" class="headerlink" title="字符串拼接的底层原理"></a>字符串拼接的底层原理</h2><ul>
<li>在拼接时没有变量全是字符串的情况下，触发字符串的优化机制。在编译时就已经是最终结果了，会复用串池中的字符串</li>
<li>在拼接时有变量参与的情况下，会创建一个StringBuilder对象将相应的变量进行相加，每相加一个就创建一个新的StringBuilder，最后再使用toString方法转换成String返回，但toString方法底层原理是创建一个String对象，所以带有变量拼接是比较麻烦的且浪费内存</li>
<li>在JDK8之后会对字符串拼接的时候会对每个相加进行预估，作用并不明显</li>
</ul>
<h2 id="StringBuilder源码分析"><a href="#StringBuilder源码分析" class="headerlink" title="StringBuilder源码分析"></a>StringBuilder源码分析</h2><ul>
<li>默认创建一个长度为16的字节数组</li>
<li>添加的内容长度小于16，直接存</li>
<li>添加的内容大于16会扩容（原来的容量*2+2）</li>
<li>如果扩容之后还不够，以实际长度为准</li>
</ul>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>static表示静态，是java中的一个修饰符，可以修饰成员方法，成员变量</p>
<p>static变量是共享的 放在静态存储区中 </p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h1 id="继承中构造方法的访问特点"><a href="#继承中构造方法的访问特点" class="headerlink" title="继承中构造方法的访问特点"></a>继承中构造方法的访问特点</h1><ul>
<li>子类不能继承父类的构造方法，但是能够通过super调用</li>
<li>子类构造方法的第一行，有一个默认的super()</li>
<li>默认先访问父类中无参的构造方法，再执行自己的</li>
<li>如果想要访问父类有参构造，必须手动书写</li>
</ul>
<h2 id="this-super的概念总结"><a href="#this-super的概念总结" class="headerlink" title="this,super的概念总结"></a>this,super的概念总结</h2><ul>
<li><strong>this相当于一个局部变量</strong>，表示当前方法调用者的地址值</li>
<li>super：代表父类存储空间</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="单列集合"><a href="#单列集合" class="headerlink" title="单列集合"></a>单列集合</h2><p>List系列集合：添加的元素是 <strong>有序、有重复、有索引</strong></p>
<p>set系列集合：添加的元素是 <strong>无序、不重复、无索引</strong></p>
<h2 id="集合遍历-Iterator"><a href="#集合遍历-Iterator" class="headerlink" title="集合遍历 Iterator"></a>集合遍历 Iterator</h2><p>迭代器在Java中的类是Iterator，迭代器是集合专用的遍历方式</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul>
<li>调用成员变量：编译看左边，运行也看左边<ul>
<li>编译看左边：javac编译代码的时候，会看左边父类中有没有这个变量，如果有，编译成功，如果没有编译失败。</li>
<li>运行也看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值</li>
</ul>
</li>
<li>调用成员方法：编译看左边，运行看右边<ul>
<li>编译看左边：javac编译代码的时候，会看左边父类中有没有这个变量，如果有，编译成功，如果没有编译失败。</li>
<li>运行看右边：java运行代码的时候，实际上运行的子类中的方法</li>
</ul>
</li>
</ul>
<h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><p>方法中，使用父类型作为参数，可以接收所有子类对象</p>
<h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能使用子类的特有功能</p>
<h2 id="引用数据类型的类型转换，有几种方式"><a href="#引用数据类型的类型转换，有几种方式" class="headerlink" title="引用数据类型的类型转换，有几种方式"></a>引用数据类型的类型转换，有几种方式</h2><ul>
<li><p>自动类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制类型转换</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student)p;</span><br></pre></td></tr></table></figure>

<h2 id="强制类型转换能解决什么问题"><a href="#强制类型转换能解决什么问题" class="headerlink" title="强制类型转换能解决什么问题"></a>强制类型转换能解决什么问题</h2><ul>
<li>可以转换成真正的子类类型，从而调用子类独有的功能</li>
<li>转换类型与真实类型不一致会报错</li>
<li>转换的时候用instanceof关键字进行判断</li>
</ul>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="内部类的访问特点"><a href="#内部类的访问特点" class="headerlink" title="内部类的访问特点"></a>内部类的访问特点</h2><ul>
<li>内部类可以直接访问外部类的成员，包括私有</li>
<li>外部类要访问内部类的成员，必须创建对象</li>
</ul>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ul>
<li>静态内部类也是成员内部类中的一种</li>
<li>静态内部类智能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建外部类的对象</li>
<li>创建静态内部类对象的格式<ul>
<li>外部类名.内部类名 对象名 &#x3D; new 外部类目.内部类名();</li>
</ul>
</li>
<li>调用静态方法的格式<ul>
<li>外部类名.内部类名.方法名（）；</li>
</ul>
</li>
</ul>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>匿名内部类的本质就是隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置</p>
<h2 id="匿名内部类的格式"><a href="#匿名内部类的格式" class="headerlink" title="匿名内部类的格式"></a>匿名内部类的格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类名或者接口名()&#123;</span><br><span class="line">	重写方法;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="格式的细节"><a href="#格式的细节" class="headerlink" title="格式的细节"></a>格式的细节</h2><ul>
<li>包含了继承或实现，方法重写，创建对象</li>
<li>整体就是一个类的子类对象或者接口的实现类对象</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当方法的参数是接口或者类时，以接口为例，可以传递这个接口的实现类对象，如果实现类只要使用一次，就可以使用匿名内部类简化代码。</p>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><ul>
<li><strong>object是java中的顶级父类</strong></li>
</ul>
<p>所有的类都直接或间接的继承于Object类。</p>
<ul>
<li><strong>toString（）：</strong>一般都会重写，打印对象时打印属性</li>
<li><strong>equals()：</strong>比较对象的时候会重写，比较对象属性值是否相同</li>
<li><strong>clone()：</strong>默认浅克隆，如果需要深克隆需要重写方法或者使用第三方工具类</li>
</ul>
<h1 id="objects类"><a href="#objects类" class="headerlink" title="objects类"></a>objects类</h1><ul>
<li>**equals():**对比object类的equals方法 多一个空参判断</li>
</ul>
<h1 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h1><h2 id="BigInteger-对象获取"><a href="#BigInteger-对象获取" class="headerlink" title="BigInteger 对象获取"></a>BigInteger 对象获取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">b1</span> <span class="operator">=</span> BigInteger.valueof(<span class="number">0.1</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;整数&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><ul>
<li>加：add</li>
<li>减: subtract</li>
<li>乘：multiply</li>
<li>除：divide、divideAndRemainder</li>
<li>比较：equals、max、min</li>
<li>次幂：pow</li>
<li>转成整数：intValue、longValue</li>
</ul>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>对象获取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建正则表达式的规则</span></span><br><span class="line">String regex;</span><br><span class="line"><span class="comment">//按照正则表达式的规则，去获取数据</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"><span class="comment">//按照pattern的规则去字符串中获取数据</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(字符串);</span><br><span class="line"><span class="keyword">while</span>(matcher.find)&#123;</span><br><span class="line">    <span class="comment">//group即为根据正则表达式筛选出来的数据</span></span><br><span class="line">    <span class="comment">//index表示获取正则表达式中的第几组数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> matcher.group(index);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h1><h2 id="Collection-单列集合"><a href="#Collection-单列集合" class="headerlink" title="Collection 单列集合"></a>Collection 单列集合</h2><ul>
<li><p>List ：<strong>添加的元素是有序的、可重复、有索引</strong></p>
<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector（已被淘汰）</li>
</ul>
</li>
<li><p>Set：<strong>无序、不重复、无索引</strong></p>
<ul>
<li>HashSet：无序、不重复、无索引<ul>
<li>LinkedHashSet：有序、不重复、无索引</li>
</ul>
</li>
<li>TreeSet：可排序、不重复、无索引</li>
</ul>
</li>
</ul>
<p>如果在遍历过程中需要删除元素，就使用<strong>迭代器</strong></p>
<p>如果仅仅是想遍历，那么使用<strong>增强for</strong>或者<strong>Lambda表达式</strong></p>
<h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><p>​	迭代器在Java中的类是Iterator，迭代器是集合专用的遍历方式</p>
<p><strong>Collection集合获取迭代器</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Iterator<E> iterator()</td>
<td>返回迭代器对象，默认指向当前集合的0索引</td>
</tr>
</tbody></table>
<p><strong>Iterator中的常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext(）</td>
<td>判断当前位置是否有元素，有元素返回true,没有元素返回false</td>
</tr>
<tr>
<td>E next()</td>
<td>获取当前位置的元素，并将迭代器对象移向下一个位置</td>
</tr>
</tbody></table>
<p><strong>迭代器的四个细节</strong></p>
<ul>
<li>如何当前位置没有元素，还要强行获取，会报NoSuchElementException</li>
<li>迭代器遍历完毕，指针不会复位</li>
<li>循环中只能用一次next方法</li>
<li>迭代器遍历时，不能用集合的方法进行增加或者删除</li>
</ul>
<h3 id="增强for遍历"><a href="#增强for遍历" class="headerlink" title="增强for遍历"></a>增强for遍历</h3><ul>
<li>增强for的底层就是迭代器，为了简化迭代器的代码书写的</li>
<li>它是JDK5之后出现的，其内部原理就是一个Iterator迭代器</li>
<li>所有的单列集合和数组才能使用增强for进行遍历</li>
</ul>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>（元素的数据类型 变量名 ： 数组或者集合）</span><br></pre></td></tr></table></figure>

<p> <strong>增强for的细节</strong></p>
<ul>
<li>修改增强for中的变量，不会改变集合中原本的数据</li>
</ul>
<h3 id="Lambda-表达式遍历"><a href="#Lambda-表达式遍历" class="headerlink" title="Lambda 表达式遍历"></a>Lambda 表达式遍历</h3><ul>
<li>其实也会自己遍历集合，依次得到每一个元素</li>
<li>把得到的每一个元素，传递给下面的accept方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>default void forEach(Consumer&lt;? super T&gt;action):</td>
<td>结合lambda遍历集合</td>
</tr>
</tbody></table>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul>
<li>在调用方法的时候，如果方法出现了重载现象，优先调用 <strong>实参跟形参类型一致的那个方法</strong></li>
</ul>
<p>在遍历的方法中添加了一个列表迭代器，在需要<strong>添加元素</strong>的时候可以使用</p>
<h3 id="ArrayList集合底层原理"><a href="#ArrayList集合底层原理" class="headerlink" title="ArrayList集合底层原理"></a>ArrayList集合底层原理</h3><ol>
<li>利用空参创建的集合，在底层创建一个默认长度为0的数组</li>
<li>添加第一个元素时，底层会创建一个新的长度为10的数组 &#x2F;&#x2F; </li>
<li>存满时，会扩容1.5倍（grow（）函数 第一次扩容是添加10长度，第二次之后是通过ArraysSupport的newLength函数如果长度大于1.5倍则选择增加所需长度）</li>
<li>如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准</li>
</ol>
<h3 id="LinkedList集合底层原理"><a href="#LinkedList集合底层原理" class="headerlink" title="LinkedList集合底层原理"></a>LinkedList集合底层原理</h3><ul>
<li>底层数据结构是双链表，查询慢，增删快，但是如果操作的是首尾元素，速度也是极快的。</li>
<li>LinkedList本身多了很多直接操作首尾元素的特有API</li>
</ul>
<table>
<thead>
<tr>
<th>特有方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void addFirst(E e)</td>
<td>在该列表的开头插入指定的元素</td>
</tr>
<tr>
<td>void addLast(E e)</td>
<td>将指定的元素追加到此列表的末尾</td>
</tr>
<tr>
<td>E getFirst()</td>
<td>返回此列表的第一个元素</td>
</tr>
<tr>
<td>E getLast()</td>
<td>返回此列表中的最后一个元素</td>
</tr>
<tr>
<td>E removeFirst()</td>
<td>删除第一个元素</td>
</tr>
<tr>
<td>E removeLast()</td>
<td>删除最后一个元素</td>
</tr>
</tbody></table>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul>
<li>HashSet集合底层采取 <strong>哈希表</strong>存储数据</li>
<li>哈希表是一种对于增删改查数据性能都较好的结构</li>
<li>哈希表的组成，在JDK8之前是数组+链表，JDK8之后是数组+链表+红黑树</li>
</ul>
<h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><ul>
<li>根据hashCode方法算出来的int类型的整数</li>
<li>该方法定义在Object类中，所有对象都可以调用，默认使用地址值进行计算</li>
<li>一般情况下，会重写hashCode方法，利用对象内部的属性值计算哈希值</li>
</ul>
<p><strong>对象的哈希值特点</strong>：</p>
<ul>
<li>如果没有重写hashCode方法，不同对象计算出的哈希值是不同的</li>
<li>如果已经重写hashCode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的</li>
<li>在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样（哈希碰撞）</li>
</ul>
<h4 id="HashSet底层原理"><a href="#HashSet底层原理" class="headerlink" title="HashSet底层原理"></a>HashSet底层原理</h4><ol>
<li>创建一个默认长度为16，默认加载因子为0.75的数组，数组名为table</li>
<li>根据元素的哈希值跟数组的长度计算出应该存入的位置</li>
<li>判断当前位置是否为null，如果是null直接存入</li>
<li>如果位置不为null，表示有元素，则调用equals方法比较属性值</li>
<li>一样： 不存       不一样：存入数组，形成链表 </li>
<li>在JDK8之前：新元素存入数组，老元素挂在新元素下面，JDK8之后：新元素直接挂在老元素下面</li>
<li>JDK8之后，链表长度超过8，而且数组长度大于等于64时，自动转换成红黑树</li>
<li>如果集合中存储的是自定义对象，必须要重写hashCode和equals方法</li>
</ol>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><ul>
<li><p>有序、不重复、无索引</p>
</li>
<li><p>底层基于哈希表，使用双链表记录添加顺序</p>
</li>
<li><p>默认情况下使用HashSet进行数据去重，如果要求去重而且存取有序，才使用LinkedHashSet</p>
</li>
</ul>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><ul>
<li>可排序、不重复、无索引</li>
<li>底层基于红黑树实现排序，增删改查性能比较好</li>
</ul>
<h3 id="TreeSet集合自定义排序规则有几种方式"><a href="#TreeSet集合自定义排序规则有几种方式" class="headerlink" title="TreeSet集合自定义排序规则有几种方式"></a>TreeSet集合自定义排序规则有几种方式</h3><ol>
<li>Javabean类实现Comparable接口，指定比较规则</li>
<li>创建集合时，自定义Comparator比较器对象，指定比较规则</li>
</ol>
<p><strong>方法返回值的特点</strong></p>
<ul>
<li>负数：表示当前要添加的元素是小的，存左边</li>
<li>正数：表示当前要添加的元素是大的，存右边</li>
<li>0：表示当前要添加的元素已经存在，舍弃</li>
</ul>
<h3 id="集合总结"><a href="#集合总结" class="headerlink" title="集合总结"></a>集合总结</h3><ol>
<li>如果想要集合中的元素可重复</li>
</ol>
<ul>
<li>使用ArrayList集合，基于数组（用的最多）</li>
</ul>
<ol start="2">
<li>如果想要集合中的元素可重复，而且当前的增删操作明显多于查询</li>
</ol>
<ul>
<li>用LinkedList集合，基于链表的</li>
</ul>
<ol start="3">
<li>如果想对集合中的元素去重</li>
</ol>
<ul>
<li>用HashSet集合，基于哈希表（用的最多）</li>
</ul>
<ol start="4">
<li>如果想对集合中的元素去重，而且保证存取顺序</li>
</ol>
<ul>
<li>用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet</li>
</ul>
<ol start="5">
<li>如果想对集合中的元素进行排序</li>
</ol>
<ul>
<li>用TreeSet集合，基于红黑树。后续也可以用List集合实现排序</li>
</ul>
<h1 id="双列集合"><a href="#双列集合" class="headerlink" title="双列集合"></a>双列集合</h1><ul>
<li>双列集合一次需要存一对数据，分别为键和值</li>
<li>键不能重复，值可以重复</li>
<li>键和值是一一对应的，每一键只能找到自己对应的值</li>
<li>键+值这个整体我们称之为“键值对”或者“键值对对象”，在Java中叫做“Entry对象”</li>
</ul>
<p>Map</p>
<ul>
<li>HashMap<ul>
<li>LinkedHashMap</li>
</ul>
</li>
<li>TreeMap</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map<strong>第一种遍历方法</strong>：获取所有的键值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; strings = map.keySet();</span><br></pre></td></tr></table></figure>

<p>Map<strong>第二种遍历方法</strong>：获取所有的键值对对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br></pre></td></tr></table></figure>

<p>Map<strong>第三种遍历方法</strong>：lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s, String s2)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li>HashMap底层是哈希表结构的</li>
<li>依赖hashCode方法和equals方法保证键的唯一</li>
<li>如果键存储的是自定义对象，需要重写hashCode和equals方法</li>
<li>如果值存储自定义对象，不需要重写hashCode和equals方法</li>
</ul>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>在编译阶段约束操作的数据类型，并进行检查</p>
<h2 id="泛型在集合中的应用"><a href="#泛型在集合中的应用" class="headerlink" title="泛型在集合中的应用"></a>泛型在集合中的应用</h2><ul>
<li>如果没有给集合指定类型，默认认为所有的数据类型都是object类型</li>
<li>此时可以往集合添加任意的数据类型，<strong>但这样做会带来一个坏处</strong>：在获取数据的时候，无法使用他的特有行为</li>
<li>此时就退出了 <strong>泛型</strong>，可以在添加数据的时候就把类型进行统一</li>
<li>泛型的作用是把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来</li>
</ul>
<p> <strong>Java中的泛型是伪泛型</strong></p>
<h2 id="泛型的应用场景"><a href="#泛型的应用场景" class="headerlink" title="泛型的应用场景"></a>泛型的应用场景</h2><ol>
<li>如果我们在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口</li>
<li>如果类型不确定，但是能知道以后智能传递某个继承体系中的，就看缘分使用泛型的通配符</li>
</ol>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ul>
<li><p>红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构</p>
</li>
<li><p><strong>每一个节点可以是红或者黑</strong>；红黑树<strong>不是高度平衡的</strong>，它的平衡是通过<strong>“红黑规则”</strong>进行实现的</p>
</li>
<li><p>红黑树是一颗二叉查找树</p>
</li>
<li><p>但是不是高度平衡的</p>
</li>
<li><p>条件：特有的红黑规则</p>
</li>
</ul>
<h2 id="红黑节点"><a href="#红黑节点" class="headerlink" title="红黑节点"></a>红黑节点</h2><ul>
<li>每一个节点或是红色的，或者是黑色的</li>
<li>根节点必须是黑色的</li>
<li>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点（Nil）是黑色的</li>
<li>如果某一个节点是红色，那么它的子节点必须是黑色（不能出现两个红色节点相连的情况）</li>
<li>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</li>
</ul>
<p><img src="/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9.assets/image-20230225165326438.png" alt="image-20230225165326438"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><ul>
<li><p>可变参数本质上其实是一个数组</p>
</li>
<li><p>作用:在形参中接收多个数据</p>
</li>
<li><p>格式：数据类型…参数名称</p>
<p>举例:int … a</p>
</li>
<li><p>注意事项</p>
<ul>
<li>形参列表中可变参数只有一个</li>
<li>可变参数必须放在形参列表的最后面</li>
</ul>
</li>
</ul>
<h1 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h1><p>创建不可变集合的应用场景</p>
<ul>
<li>如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践</li>
<li>当集合对象被不可信的库调用时，不可变形式是安全的</li>
</ul>
<p><strong>如何创建不可变集合</strong></p>
<ul>
<li>List、Set、Map接口中，都存在of方法可以创建不可变集合</li>
</ul>
<p>三种方式的细节</p>
<ul>
<li>List：直接用</li>
<li>Set：元素不能重复</li>
<li>Map：元素不能重复、键值对的数量最多是10个，超过十个使用ofEntries方法</li>
</ul>
<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p>结合了Lambda表达式，简化集合、数组的操作</p>
<table>
<thead>
<tr>
<th>集合类型</th>
<th>创建方法</th>
<th>方法类型</th>
</tr>
</thead>
<tbody><tr>
<td>单列集合</td>
<td>default Stream<E> stream()</td>
<td>Collection中的默认方法</td>
</tr>
<tr>
<td>双列集合</td>
<td>无</td>
<td>无法直接使用stream流</td>
</tr>
<tr>
<td>数组</td>
<td>public static <T> Stream<T> stream(T[] array)</td>
<td>Arrays工具类中的静态方法</td>
</tr>
<tr>
<td>一堆零散数据</td>
<td>public static<T> Stream<T> of (T…..values)</td>
<td>Stream接口中的静态方法</td>
</tr>
</tbody></table>
<p>Stream接口中的静态方法of的细节</p>
<ul>
<li>方法的形参是一个可变参数，可以传递一堆零散的数据，也可以传递数组</li>
<li>但是数组必须是引用数据类型的，如果传递基本数据类型，是会把数据当做一整个元素放到Stream中</li>
</ul>
<h2 id="Stream的使用步骤"><a href="#Stream的使用步骤" class="headerlink" title="Stream的使用步骤"></a>Stream的使用步骤</h2><ul>
<li>获取Stream流对象</li>
<li>使用中间方法处理数据</li>
<li>使用终结方法处理数据</li>
</ul>
<h2 id="如何获取Stream流对象"><a href="#如何获取Stream流对象" class="headerlink" title="如何获取Stream流对象"></a>如何获取Stream流对象</h2><ul>
<li>单列集合：Collection中的默认方法stream</li>
<li>双列集合：不能直接获取</li>
<li>数组：Arrays工具类中的静态方法stream</li>
<li>一堆零散的数据：Stream接口中的of方法</li>
</ul>
<h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><ul>
<li>中间方法：filter,limit,skip,distinct,concat,map</li>
<li>终结方法: forEach、count、collect</li>
</ul>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>使用的几个条件：</p>
<ol>
<li>引用处需要是函数式接口</li>
<li>被引用的方法需要已经存在</li>
<li>被引用方法的形参和返回值需要跟抽象方法的形参和返回值保持一致</li>
<li>被引用方法的功能需要满足当前的要求</li>
</ol>
<p>方法引用是把已经存在的方法拿过来用，当做函数式接口中抽象方法的方法体</p>
<p>：：是方法引用符</p>
<h2 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h2><p>类名：：静态方法</p>
<h2 id="引用成员方法"><a href="#引用成员方法" class="headerlink" title="引用成员方法"></a>引用成员方法</h2><ol>
<li>对象：：成员方法</li>
<li>this：：成员方法 &#x2F;&#x2F; 不能在静态方法中使用</li>
<li>super：：成员方法 &#x2F;&#x2F;</li>
</ol>
<h2 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h2><p>类名：：new</p>
<h2 id="使用类名引用成员方法"><a href="#使用类名引用成员方法" class="headerlink" title="使用类名引用成员方法"></a>使用类名引用成员方法</h2><p>类名：：成员方法</p>
<p>不能引用所有类中的成员方法</p>
<p>如果抽象方法的第一个参数是A类型的</p>
<p>只能引用A类中的方法</p>
<h2 id="引用数组的构造方法"><a href="#引用数组的构造方法" class="headerlink" title="引用数组的构造方法"></a>引用数组的构造方法</h2><p>数据类型[] :: new</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><img src="https://cdn.jsdelivr.net/gh/LYHazard/blog.img/202303022129958.png" alt="image-20230302212937588"></p>
<h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><table>
<thead>
<tr>
<th>构造方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>public File(String pathname)</td>
<td>根据文件路径创建文件对象</td>
</tr>
<tr>
<td>public File(String parent,String child)</td>
<td>根据父路径名字符串和子路径名字符串创建文件对象</td>
</tr>
<tr>
<td>public File(File parent, String child)</td>
<td>根据父路径对应文件对象和子路径名字符串创建文件对象</td>
</tr>
</tbody></table>
<ol>
<li>File表示什么：File对象表示路径，可以是文件、也可以是文件夹 这个路径可以是存在的，也可以是不存在的</li>
<li>绝对路径和相对路径是什么意思：</li>
</ol>
<ul>
<li>绝对路径是带盘符的。</li>
<li>相对路径是不带盘符的，默认到当前项目下去找</li>
</ul>
<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>IO流中，是程序在读，程序在写。</p>
<p>存储和读取数据的解决方案</p>
<p>IO流的作用： 用于读写数据（本地文件，网络）</p>
<p><strong>流的方向</strong>：</p>
<p>IO流</p>
<ul>
<li>输入流  读取</li>
<li>输出流  写出</li>
</ul>
<p><strong>操作文件类型</strong>：</p>
<ul>
<li>字节流：所有类型的文件</li>
<li>字符流：只能操作纯文本文件</li>
</ul>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="字节输出流"><a href="#字节输出流" class="headerlink" title="字节输出流"></a>字节输出流</h3><ol>
<li>创建字节输出流对象</li>
</ol>
<ul>
<li>细节1：参数是字符串表示的路径或者是file对象也可以</li>
<li>细节2：如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的</li>
<li>细节3：如果文件已经存在，则会清空文件</li>
</ul>
<ol start="2">
<li>写数据</li>
</ol>
<ul>
<li>细节1：write方法的参数是整数，但是实际上写到本地文件中的是整数在ASCII上对应的字符</li>
</ul>
<ol start="3">
<li>释放资源</li>
</ol>
<ul>
<li>每个流都要释放资源</li>
</ul>
<h3 id="字节输入流"><a href="#字节输入流" class="headerlink" title="字节输入流"></a>字节输入流</h3><ol>
<li><p>创建字节输入流对象</p>
<p>细节1：如果文件不存在，就直接报错</p>
</li>
<li><p>读取数据</p>
</li>
</ol>
<ul>
<li>一次读一个字节，读出来的是数据在ASCII上对应的数字</li>
<li>读到文件末尾了，read方法返回-1</li>
</ul>
<ol start="3">
<li>释放资源</li>
<li>不能在同一个循环中反复调用，因为每执行一次read()方法就会移动一次指针，所以需要一个代码赋值</li>
</ol>
<p>如果读取大文件可以使用 <strong>字节数组的方式读取</strong></p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>底层是字节流</p>
<h3 id="FileRead"><a href="#FileRead" class="headerlink" title="FileRead"></a>FileRead</h3><p>read方法细节: </p>
<ul>
<li>read():默认是一个字节一个字节读取的，如果遇到中文就会一次读取多个</li>
<li>在读取之后，方法的底层还会进行解码并转成十进制，最终把这个十进制作为返回值，这个十进制的数据也表示在字符集上的数字</li>
</ul>
<h3 id="字符流原理解析"><a href="#字符流原理解析" class="headerlink" title="字符流原理解析"></a>字符流原理解析</h3><h3 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h3><ol>
<li>创建字符输入流对象</li>
</ol>
<p>  底层：关联文件，并创建缓冲区（长度为8192的字节数组）</p>
<ol start="2">
<li>读取数据</li>
</ol>
<p>底层：</p>
<ol>
<li><p>判断缓冲区中是否有数据可以读取</p>
</li>
<li><p><strong>缓冲区中没有数据：</strong>就从文件中获取数据，装到缓冲区中，每次尽可能装满缓冲区，如果文件中也没有数据了，返回-1</p>
</li>
<li><p><strong>缓冲区中有数据</strong>：就从缓冲区中读取。（缓冲区大小为8192）</p>
<p>空参的read方法：一次读取一个字节，遇到中文一次读取多个字节，把字节解码并转成十进制返回。</p>
<p>有参的read方法：把读取字节，解码，强转三步合并，强转之后的字符放到数组中</p>
</li>
</ol>
<p><strong>创建字符输入流既往缓冲区中加入数据</strong></p>
<h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><ul>
<li>缓冲流自带长度为8192的缓冲区</li>
<li>可以显著提高字节流的读写性能</li>
<li>对于字符流提升不明显，对于字符缓冲流而言关键的是两个特有方法</li>
</ul>
<h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>构造方法</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>BufferedInputStream(InputStream in)</td>
<td>字节输入流</td>
</tr>
<tr>
<td>BufferedInputStream(OutputStream out)</td>
<td>字节输出流</td>
</tr>
</tbody></table>
<h3 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h3><p>构造方法</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public BufferedReader(Reader r)</td>
<td>把基本流变成高级流</td>
</tr>
<tr>
<td>public BufferedWriter(Writer w)</td>
<td>把基本流变成高级流</td>
</tr>
</tbody></table>
<h3 id="字符缓冲流特有方法"><a href="#字符缓冲流特有方法" class="headerlink" title="字符缓冲流特有方法"></a>字符缓冲流特有方法</h3><table>
<thead>
<tr>
<th>字符缓冲流输入流特有方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String readLine()</td>
<td align="left">读取一行数据，如果没有数据可读了，会返回null</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>字符缓冲流输出流特有方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>public void newLine()</td>
<td align="left">跨平台的换行</td>
</tr>
</tbody></table>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><ul>
<li>字符转换输入流：inputStreamReader</li>
<li>字符转换输出流：OutputStreamWriter</li>
</ul>
<p>转换流的作用：</p>
<ul>
<li>指定字符集读写数据（jdk11之后淘汰了）</li>
<li>字节流想要使用字符流中的方法了</li>
</ul>
<h2 id="序列化流"><a href="#序列化流" class="headerlink" title="序列化流"></a>序列化流</h2><ol>
<li>需要实现Serializable接口</li>
<li>序列化流写到文件中的数据是不可修改的，一旦修改就无法再次读回来了</li>
<li>序列化对象后，修改了Javabean类，再次反序列化，会出问题，抛出InvalidClassException异常，给javabean类加上SerialVersionUID（序列号）就不会报错，Idea上有自动生成的配置</li>
<li>如果某个变量不想被序列化，那么给此变量加上transit关键字</li>
<li>序列化多个对象的时候要先把对象放入集合当中，读取时直接读取集合</li>
</ol>
<h3 id="对象操作输出流"><a href="#对象操作输出流" class="headerlink" title="对象操作输出流"></a>对象操作输出流</h3><p>可以把java中的对象写到本地文件中</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ObjectOutputStream(OutputStream out)</td>
<td>把基本流包装成高级流</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public final void writeObject(Object obj)</td>
<td>把对象序列化（写出）到文件中去</td>
</tr>
</tbody></table>
<h2 id="对象操作输入流"><a href="#对象操作输入流" class="headerlink" title="对象操作输入流"></a>对象操作输入流</h2><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public ObjectInputStream(InputStream out)</td>
<td>把基本流变成高级流</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Object readObject</td>
<td>把序列化到本地文件中的对象，读取到程序中来</td>
</tr>
</tbody></table>
<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>分类：打印流是指，PrintStream，PrintWrite两个类</p>
<p>特点1：打印流致操作文件的目的地，不操作数据源</p>
<p>特点2：特有的写出方法可以实现，数据原样写出</p>
<p>特点3: 特有的写出方法，可以实现自动刷新，自动换行</p>
<ul>
<li>打印流不操作数据源，只能操作目的地</li>
<li>字节打印流：默认自动刷新，特有的println自动换行</li>
<li>字符打印流: 自动刷新需要开启，特有的println自动换行</li>
</ul>
<h3 id="字节打印流"><a href="#字节打印流" class="headerlink" title="字节打印流"></a>字节打印流</h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public PrintStream(OutputStream&#x2F;File&#x2F;String)</td>
<td>关联字节输出流&#x2F;文件&#x2F;文件路径</td>
</tr>
<tr>
<td>public PrintStream（String filename，Charset charset）</td>
<td>指定字符编码</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int b)</td>
<td>常规方法，规则跟之前一样，将指定的字节写出</td>
</tr>
<tr>
<td>void println(XXX xx )</td>
<td><strong>特有方法：</strong>打印任意数据，自动刷新，自动换行</td>
</tr>
<tr>
<td>void print(XXX xx )</td>
<td><strong>特有方法：</strong>打印任意数据，不换行</td>
</tr>
<tr>
<td>void printf（String format，Object….args）</td>
<td><strong>特有方法：</strong>带有占位符的打印语句，不换行</td>
</tr>
</tbody></table>
<h3 id="字符打印流"><a href="#字符打印流" class="headerlink" title="字符打印流"></a>字符打印流</h3><table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public PrintWriter(OutputStream&#x2F;File&#x2F;String)</td>
<td>关联字节输出流&#x2F;文件&#x2F;文件路径</td>
</tr>
<tr>
<td>public PrintWriter（String filename，Charset charset）</td>
<td>指定字符编码</td>
</tr>
</tbody></table>
<h2 id="转换流-1"><a href="#转换流-1" class="headerlink" title="转换流"></a>转换流</h2><p>把字节流转换成字符流</p>
<p>InputStreamReader</p>
<p>OutputStreamWriter</p>
<h2 id="解压缩流"><a href="#解压缩流" class="headerlink" title="解压缩流"></a>解压缩流</h2><h3 id="压缩流"><a href="#压缩流" class="headerlink" title="压缩流"></a>压缩流</h3><p>压缩的本质：把每一个（文件&#x2F;文件夹）看成是ZipEntry对象放到压缩包中</p>
<p>解压的本质：把压缩包中的每一个文件或者文件夹(Entry)都读取出来，按照层级拷贝到目的地中</p>
<h1 id="第三方jar包的使用"><a href="#第三方jar包的使用" class="headerlink" title="第三方jar包的使用"></a>第三方jar包的使用</h1><ol>
<li>在项目中创建一个文件夹lib</li>
<li>将jar包复制黏贴到lib文件夹当中</li>
<li>右键点击jar包，选择Add as Library -&gt; 点击OK</li>
<li>在类中导包使用</li>
</ol>
<h1 id="配置文件properties"><a href="#配置文件properties" class="headerlink" title="配置文件properties"></a>配置文件properties</h1><ul>
<li>把软件的设置永久化存储</li>
<li>如果需要修改参数，不需要改动代码，直接修改配置文件就可以</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>在同一时刻，有多个指令在单个cpu上交替执行</p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>在同一时刻，有多个指令在多个CPU上同时执行</p>
<h2 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h2><table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>继承Thread类</td>
<td>编程比较简单，可以直接使用Thread类中的方法</td>
<td>可拓展性差，不能再继承其他的类</td>
</tr>
<tr>
<td>实现Runnable接口</td>
<td>拓展性强，实现该接口的同时还可以继承其他的类</td>
<td>编程相对复杂，不能直接使用Thread类中的方法</td>
</tr>
<tr>
<td>实现Callable接口</td>
<td>拓展性强，实现该接口的同时还可以继承其他的类</td>
<td>可以获取线程中获得的数据</td>
</tr>
</tbody></table>
<h2 id="多线程的生命周期"><a href="#多线程的生命周期" class="headerlink" title="多线程的生命周期"></a>多线程的生命周期</h2><ol>
<li>在调用.start()方法后线程将转为就绪态</li>
<li>在就绪态的线程抢占到cpu资源后会转为执行态</li>
<li>执行态的线程丢失掉资源后会转为就绪态</li>
<li>执行态的线程在执行sleep方法后会转为阻塞态</li>
<li>执行态的线程执行完run()方法后会转换成死亡态</li>
</ol>
<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><ol>
<li>在操作共享数据时，会因为多个线程的抢占资源导致共享数据被多个线程同时执行，导致结果出现问题</li>
<li>用syncronized关键字添加上一个锁对象，在此关键字范围中的代码一次只能有一个线程进行执行</li>
</ol>
<h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h2><p>实现方式1，提供中间人</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.Thread.producer_consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1. 循环</span></span><br><span class="line"><span class="comment">         * 2. 同步代码块</span></span><br><span class="line"><span class="comment">         * 3. 判断共享数据是否到了末尾（到了末尾）</span></span><br><span class="line"><span class="comment">         * 4. 判断共享数据是否到了末尾（没有到末尾，执行核心逻辑）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Mediator.lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Mediator.count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//判断有无余量</span></span><br><span class="line">                    <span class="keyword">if</span> (Mediator.foodFlag == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//没有了，进行等待</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Mediator.lock.wait();<span class="comment">//让当前线程和锁进行绑定</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果有，就使用</span></span><br><span class="line">                        Mediator.count--;</span><br><span class="line">                        System.out.println(<span class="string">&quot;需要的粮食还剩&quot;</span> + Mediator.count);</span><br><span class="line">                        <span class="comment">//使用完后唤醒生产者生产</span></span><br><span class="line">                        Mediator.lock.notifyAll();</span><br><span class="line">                        <span class="comment">//修改存粮状态</span></span><br><span class="line">                        Mediator.foodFlag = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.Thread.producer_consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  作用：控制生产者和消费者的执行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="comment">//定义一个变量判断是否有存粮 0：表示没有 1：表示有</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">foodFlag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一下需要的粮食的总个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义锁对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.Thread.producer_consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1. 循环</span></span><br><span class="line"><span class="comment">         * 2. 同步代码块</span></span><br><span class="line"><span class="comment">         * 3. 判断共享数据是否到了末尾（到了末尾）</span></span><br><span class="line"><span class="comment">         * 4. 判断共享数据是否到了末尾（没有到末尾，执行核心逻辑）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Mediator.lock)&#123;</span><br><span class="line">                <span class="comment">//当消费者的需求为0时就不用生产了</span></span><br><span class="line">                <span class="keyword">if</span> (Mediator.count == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果桌面上还有产物,则线程等待</span></span><br><span class="line">                    <span class="keyword">if</span> (Mediator.foodFlag == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Mediator.lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;<span class="comment">//没有产物则线程开启，并生产</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;生产者开始生产&quot;</span>);</span><br><span class="line">                        Mediator.foodFlag =<span class="number">1</span>;</span><br><span class="line">                        Mediator.lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现方式二-阻塞队列"><a href="#实现方式二-阻塞队列" class="headerlink" title="实现方式二 阻塞队列"></a><strong>实现方式二</strong> 阻塞队列</h3><p><img src="/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9.assets/image-20230314143330999-16787756136801.png" alt="image-20230314143330999"></p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>新建状态（NEW） –》 创建线程对象</p>
<p>就绪状态（RUNNABLE） –》start方法</p>
<p>阻塞状态（BLOCKED） –》无法获得锁对象</p>
<p>等待状态（WAITING） –》wait方法</p>
<p>计时等待（TIMED_WAITING） –》sleep方法</p>
<p>结束状态（TERMINATED） –》全部代码运行完毕</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/03/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9/" data-id="clf99j8ra000gokm67at28fge" data-title="java 常识内容" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java-内存相关" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/20/java-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/" class="article-date">
  <time class="dt-published" datetime="2022-12-20T01:05:54.000Z" itemprop="datePublished">2022-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/20/java-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/">java 内存相关</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="栈相关"><a href="#栈相关" class="headerlink" title="栈相关"></a>栈相关</h1><p><strong>方法</strong>运行时使用的内存，方法进栈运行，运行完毕就出栈</p>
<h1 id="堆相关"><a href="#堆相关" class="headerlink" title="堆相关"></a>堆相关</h1><p><strong>new</strong>出来的，都在堆内存中开辟一个小空间</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>存储可以运行的class文件</p>
<p>当运行一个类的时候字节码文件加载时进入的内存</p>
<h1 id="本地方法寄存器"><a href="#本地方法寄存器" class="headerlink" title="本地方法寄存器"></a>本地方法寄存器</h1><p>JVM在使用操作系统功能的时候使用，和开发无关</p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>给CPU使用，和开发无关</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><strong>基本数据类型</strong>：数据值是存储在自己的控件当中的 特点是：赋值给其他变量，也是赋的真实的值</p>
<p><strong>引用数据类型</strong>：数据值是存储在其他空间中，自己空间中存储的是地址值</p>
<h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this代表着方法调用者的地址值；  </p>
<h1 id="字符串内存原理"><a href="#字符串内存原理" class="headerlink" title="字符串内存原理"></a>字符串内存原理</h1><p>当使用双引号直接赋值时，系统会检查该字符串在串池中是否存在，<strong>不存在：创建新的  存在：复用</strong></p>
<p>通过new出来的字符串，字符串内容不会复用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/20/java-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/" data-id="clf99j8r9000eokm6c04q4t3k" data-title="java 内存相关" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-源码、补码、反码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/10/%E6%BA%90%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/" class="article-date">
  <time class="dt-published" datetime="2022-12-10T05:04:38.000Z" itemprop="datePublished">2022-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/10/%E6%BA%90%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/">源码、补码、反码</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>原码：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负</strong></p>
<p><strong>反码：正数的补码反码是其本身，负数的反码是保持符号位不变，其余位取反</strong></p>
<p><strong>补码：正数的补码是其本身，负数的补码是在其反码的基础上+1</strong></p>
<h1 id="原码的弊端"><a href="#原码的弊端" class="headerlink" title="原码的弊端"></a>原码的弊端</h1><p>利用原码对正数进行计算是不会有问题的。</p>
<p>但是如果对负数进行计算，结果就出错，实际运算的结果，跟我们预期的结果是相反的</p>
<h1 id="反码出现的目的"><a href="#反码出现的目的" class="headerlink" title="反码出现的目的"></a>反码出现的目的</h1><p>为了解决原码不能计算负数的问题而出现的。</p>
<h2 id="反码的计算规则"><a href="#反码的计算规则" class="headerlink" title="反码的计算规则"></a>反码的计算规则</h2><p>正数的反码不变，负数的反码在原码的基础上，符号位不变。数值取反，0变1,1变0；</p>
<h2 id="反码的弊端"><a href="#反码的弊端" class="headerlink" title="反码的弊端"></a>反码的弊端</h2><p>负数运算时，如果结果不跨0，是没有任何问题的，但是如果结果跨0，跟实际结果会有1的偏差。</p>
<h1 id="补码出现的目的"><a href="#补码出现的目的" class="headerlink" title="补码出现的目的"></a>补码出现的目的</h1><p>为了解决负数计算时跨0的问题而出现的。</p>
<h2 id="补码的计算规则"><a href="#补码的计算规则" class="headerlink" title="补码的计算规则"></a>补码的计算规则</h2><p>正数的补码不变，负数的补码在反码的基础上+1。 </p>
<p>另外补码还能多记录一个特殊的值-128，该数据在1个字节下，没有原码和反码。</p>
<h2 id="补码的注意点"><a href="#补码的注意点" class="headerlink" title="补码的注意点"></a>补码的注意点</h2><p>计算机中的存储和计算都是以补码的形式进行的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/10/%E6%BA%90%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/" data-id="clf99j8rb000hokm6gf166n8d" data-title="源码、补码、反码" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-adb-命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/26/adb-%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2022-11-26T05:01:48.000Z" itemprop="datePublished">2022-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/26/adb-%E5%91%BD%E4%BB%A4/">adb 命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>想看比较全又不用百度的adb命令 ：adb help<br>打印本机所有软件包  adb shell pm list packages<br>输出和安装包相关联的文件 adb shell pm list packages -f<br>打印输出第三方安装包 adb shell pm list packages -3<br>输出本机禁用的包 adb shell pm list packages -d<br>输出本机启用的包 adb shell pm list packages -e<br>查看ADB版本：adb version<br>查看手机设备：adb devices<br>查看设备型号：adb shell getprop ro.product.model<br>查看电池信息：adb shell dumpsys battery<br>查看设备ID：adb shell settings get secure android_id<br>查看设备IMEI：adb shell dumpsys iphonesubinfo （好像看不了，哈哈）<br>查看Android版本：adb shell getprop ro.build.version.release<br>查看手机网络信息：adb shell ifconfig<br>查看设备日志：adb logcat （log疯狂刷）<br>重启手机设备：adb reboot<br>安装一个apk：adb install &#x2F;path&#x2F;demo.apk<br>卸载一个apk：adb uninstall com.niubi.dadada(包名)<br>保留原数据的话 adb uninstall -k 包名<br>查看系统运行进程：adb shell ps<br>查看系统磁盘情况：adb shell ls &#x2F;path&#x2F;<br>手机设备截屏：adb shell screencap -p &#x2F;sdcard&#x2F;aa.png<br>手机文件下载到电脑：adb pull &#x2F;sdcard&#x2F;aa.png .&#x2F;<br>电脑文件上传到手机：adb push aa.png &#x2F;data&#x2F;local&#x2F;<br>手机设备录像：adb shell screenrecord &#x2F;sdcard&#x2F;ab.mp4<br>手机屏幕分辨率：adb shell wm size<br>手机屏幕密度：adb shell wm density<br>连接设备 ： adb connect [[:]]（默认端口号是：5555）<br>adb disconnect &lt;设备的IP地址&gt;:端口号 ：adb断开某设备<br>adb root：进入root权限</p>
<p>adb reboot：重启设备</p>
<p>adb：remount 获取读写权限</p>
<p>adb push xxx.apk system&#x2F;app：可以指定安装位置，如系统app位置：system&#x2F;app<br>adb pull &#x2F;phone&#x2F;sdcard&#x2F;dididi.apk(手机文件地址)  C:\Users\Administrator\Desktop :将手机里文件拉取到电脑<br>adb push a.txt &#x2F;mnt&#x2F;sdcard&#x2F;  ：将电脑某一目录下的文件a.txt 传到手机指定目录mnt&#x2F;sdcad目录中</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/26/adb-%E5%91%BD%E4%BB%A4/" data-id="clf99j8r40005okm6hdgygi7q" data-title="adb 命令" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-重要计算机文件缩写" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/18/%E9%87%8D%E8%A6%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E4%BB%B6%E7%BC%A9%E5%86%99/" class="article-date">
  <time class="dt-published" datetime="2022-11-18T14:35:49.000Z" itemprop="datePublished">2022-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/18/%E9%87%8D%E8%A6%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E4%BB%B6%E7%BC%A9%E5%86%99/">重要计算机术语缩写</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机网络相关"><a href="#计算机网络相关" class="headerlink" title="计算机网络相关"></a>计算机网络相关</h1><p><strong>TCP</strong> : Transmission Control Protocol，传输控制协议</p>
<p>**IP **: Internet Protocol，网际协议</p>
<p>**IETF **：Internet Engineering Task Force，因特网工程任务组</p>
<p>**RFC **：Request For Comment，请求评论文档，目的是解决因特网先驱者们面临的网络和协议问题</p>
<p><strong>URL</strong> : uniform resource locator,统一资源定位系统</p>
<p><strong>DSL</strong> ：Digital Subscriber Line，数字用户线</p>
<p><strong>DSLAM</strong> ：数字用户线接入复用器</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/18/%E9%87%8D%E8%A6%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E4%BB%B6%E7%BC%A9%E5%86%99/" data-id="clf99j8rc000jokm6amn009rp" data-title="重要计算机术语缩写" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-git问题集锦" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/11/git%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/" class="article-date">
  <time class="dt-published" datetime="2022-11-11T13:30:58.000Z" itemprop="datePublished">2022-11-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/11/git%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/">git问题集锦</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="工作区、暂存区、版本库"><a href="#工作区、暂存区、版本库" class="headerlink" title="工作区、暂存区、版本库"></a>工作区、暂存区、版本库</h1><ul>
<li>工作区：就是你在电脑里能看到的目录。</li>
<li>暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li>版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。<br><img src="/git%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6.assets/image-20221111215622250.png" alt="image-20221111215622250"></li>
</ul>
<p><img src="/git%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6.assets/image-20221111215654411.png" alt="image-20221111215654411"></p>
<h2 id="1、提交代码到仓库"><a href="#1、提交代码到仓库" class="headerlink" title="1、提交代码到仓库"></a>1、提交代码到仓库</h2><p>1）克隆 或 拉取最新代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//克隆</span><br><span class="line">git clone http://xxx</span><br><span class="line"></span><br><span class="line">//拉取</span><br><span class="line">git pull http://xxx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2）添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xxx</span><br></pre></td></tr></table></figure>

<p>3）描述信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交&quot;</span><br></pre></td></tr></table></figure>

<p>4）推送到远程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<h2 id="2、pull拉取最新代码"><a href="#2、pull拉取最新代码" class="headerlink" title="2、pull拉取最新代码"></a>2、pull拉取最新代码</h2><p>本地仓库的代码还未被更新，此时：</p>
<p>（1）更新远程仓库的代码为最新的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br></pre></td></tr></table></figure>

<p>(2) 让本地代码与origin&#x2F;master完全相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure>

<p>(3) git pull 拉取远程代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<p>(4)git merge将暂存区代码更新到本地工作区</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge master</span><br></pre></td></tr></table></figure>

<h2 id="3、关联仓库并上传代码"><a href="#3、关联仓库并上传代码" class="headerlink" title="3、关联仓库并上传代码"></a>3、关联仓库并上传代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://gitee.com/xxx/xxx.git</span><br><span class="line">git push -u origin &quot;master&quot;</span><br></pre></td></tr></table></figure>

<p>查看关联仓库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v	</span><br></pre></td></tr></table></figure>

<h2 id="4、关联已有仓库并提交代码"><a href="#4、关联已有仓库并提交代码" class="headerlink" title="4、关联已有仓库并提交代码"></a>4、关联已有仓库并提交代码</h2><p>第一步：找到适合位置，右键打开git工具</p>
<p>第二步：克隆或拉取代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone http://xxx.git</span><br><span class="line"></span><br><span class="line">git pull http://xxx.git</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三步：创建和切换分支</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.【git branch】查看一下本地分支，再【git branch -a】查看一下远程分支，对比下，远程存在哪些本地没有的新分支.</span><br><span class="line"></span><br><span class="line">2.将某个远程主机的更新，全部取回本地：【git fetch】</span><br><span class="line"></span><br><span class="line">3.再次查看远程分支：【git branch -a】 发现远程的分支已经可以看见了</span><br><span class="line"></span><br><span class="line">4.拉取远程分支到本地：</span><br><span class="line">创建远程分支并切换到该分支:【git checkout -b (远程分支名)】 </span><br><span class="line">拉取远程分支代码到本地分支：【git pull origin (远程分支名称)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第四步、将要上传的代码拷贝到当前目录下</p>
<p>第五步、上传并提交代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add xxx/</span><br><span class="line"></span><br><span class="line">git commit -m &quot;init-1.0&quot;</span><br><span class="line"></span><br><span class="line">git push origin feature</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git branch -r  //查看远程所有分支</span><br><span class="line"></span><br><span class="line">git branch //查看本地所有分支</span><br><span class="line"></span><br><span class="line">git branch -a //查看本地及远程的所有分支</span><br><span class="line"></span><br><span class="line">git fetch  //将某个远程主机的更新，全部取回本地</span><br><span class="line"></span><br><span class="line">git remote -v //查看仓库关联情况</span><br><span class="line"></span><br><span class="line">git status //查看git状态</span><br><span class="line"></span><br><span class="line">git remote remove origin//取消与现有仓库的链接</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/11/git%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6/" data-id="clf99j8r7000aokm6be2tdgfr" data-title="git问题集锦" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java类的使用心得" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/07/java%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/" class="article-date">
  <time class="dt-published" datetime="2022-11-07T13:11:43.000Z" itemprop="datePublished">2022-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/07/java%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/">java类的使用心得</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="java-text包"><a href="#java-text包" class="headerlink" title="java.text包"></a>java.text包</h1><h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><p><code>SimpleDateFormat</code>是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。 它允许格式化（日期文本），解析（文本日期）和归一化。</p>
<p><code>SimpleDateFormat</code>允许您从选择日期时间格式化的任何用户定义的模式开始。 不过，建议您创建一个日期-时间格式有两种<code>getTimeInstance</code> ， <code>getDateInstance</code> ，或<code>getDateTimeInstance</code>在<code>DateFormat</code> 。 这些类方法中的每一个都可以返回使用默认格式模式初始化的日期&#x2F;时间格式化程序。 您可以根据需要使用<code>applyPattern</code>方法修改格式模式。 有关使用这些方法的更多信息，请参见<a target="_blank" rel="noopener" href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/text/DateFormat.html"><code>DateFormat</code></a> 。</p>
<p><strong>构造方法：</strong></p>
<ul>
<li><pre><code class="java">SimpleDateFormat（）//构造一个SimpleDateFormate使用默认模式和日期格式符号为默认的FORMAT区域设置
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  SimpleDateFormat（String pattern）//使用给定模式SimpleDateFormat并使用默认的 FORMAT语言环境的默认日期格式符号。</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>&#96;&#96;&#96;java<br>SimpleDateFormat（String pattern, DateFormatSymbols formatSymbols）&#x2F;&#x2F;使用给定的模式和日期格式符号构造一个SimpleDateFormat</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  SimpleDateFormat(String pattern, Locale locale)//构造一个 `SimpleDateFormat`使用给定的模式和给定的区域设置的默认日期格式符号。</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="java-lang-包"><a href="#java-lang-包" class="headerlink" title="java. lang 包"></a>java. lang 包</h1><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>对比String类，相当于是一个容器，其内容对比与String的不可改变，StringBuilder是可以改变的</p>
<p>1.在需要字符串拼接和字符串反转的情况下会用到StringBuilder</p>
<h2 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h2><ul>
<li>StringJoiner和StringBuilder一样，也可以看做是一个容器，创建之后里面的内容是可变的；</li>
<li>作用：提高字符串的操作效率，而且代码编写特别简洁；</li>
<li>JDK8出现的</li>
<li>在拼接中要加上开头结尾时使用</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/07/java%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/" data-id="clf99j8ra000fokm6fugvhsii" data-title="java类的使用心得" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hexo常用命令" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/03/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-date">
  <time class="dt-published" datetime="2022-11-03T03:59:51.000Z" itemprop="datePublished">2022-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/03/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">hexo常用命令</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1、hexo init<br> hexo init 命令用于初始化一个本地文件夹为网站的根目录<br>1<br>2、hexo new<br>$ hexo new title 新建一篇文章<br>1<br>3、hexo generate<br>$ hexo generate 可以简写成 hexo g<br>该命令用于生成静态文件</p>
<p>4、hexo server<br>$ hexo server 命令用于启动本地服务器，一般可以简写成 hexo s<br>可以加一些参数<br>-p    选项，指定服务器端口，默认为 4000<br>-i    选项，指定服务器 IP 地址，默认为 0.0.0.0<br>-s    选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视<br>1</p>
<p>5、hexo deploy<br>$ hexo deploy 命令用于部署网站，一般可以简写成 hexo d<br>1<br>6、hexo clean<br>$ hexo clean 命令用于清理缓存文件，是一个比较常用的命令<br>1<br>7、hexo –safe<br>$ hexo –safe 表示安全模式，用于禁用加载插件和脚本<br>1<br>8、hexo –debug<br>$ hexo –debug 表示调试模式，用于将消息详细记录到终端和 debug.log 文件<br>1<br>9、hexo –silent<br>$ hexo –silent  表示静默模式，用于静默输出到终端</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/03/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" data-id="clf99j8r9000dokm66evj1puo" data-title="hexo常用命令" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E5%B8%B8%E5%9C%A8Android-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E4%BD%86%E5%8F%88%E8%A6%81%E8%A7%84%E9%81%BF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E4%B8%80%E8%88%AC%E9%83%BD%E4%BC%9A%E9%87%87%E7%94%A8-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB-%E5%BC%B1%E5%BC%95%E7%94%A8-%E7%9A%84%E6%96%B9%E5%BC%8F/" rel="tag">通常在Android 开发中如果要使用内部类，但又要规避内存泄露，一般都会采用 静态内部类 + 弱引用 的方式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E8%BF%87%E8%A7%A3%E8%80%A6%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E8%AE%A2%E9%98%85%E8%80%85%E7%AE%80%E5%8C%96Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/" rel="tag">通过解耦发布者和订阅者简化Android事件传递</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E9%80%9A%E5%B8%B8%E5%9C%A8Android-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%8C%E4%BD%86%E5%8F%88%E8%A6%81%E8%A7%84%E9%81%BF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E4%B8%80%E8%88%AC%E9%83%BD%E4%BC%9A%E9%87%87%E7%94%A8-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB-%E5%BC%B1%E5%BC%95%E7%94%A8-%E7%9A%84%E6%96%B9%E5%BC%8F/" style="font-size: 10px;">通常在Android 开发中如果要使用内部类，但又要规避内存泄露，一般都会采用 静态内部类 + 弱引用 的方式</a> <a href="/tags/%E9%80%9A%E8%BF%87%E8%A7%A3%E8%80%A6%E5%8F%91%E5%B8%83%E8%80%85%E5%92%8C%E8%AE%A2%E9%98%85%E8%80%85%E7%AE%80%E5%8C%96Android%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/" style="font-size: 10px;">通过解耦发布者和订阅者简化Android事件传递</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/03/09/commons-io%E6%95%B4%E7%90%86%E7%9A%84%E6%96%87%E6%A1%A3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/01/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2023/01/03/java-%E5%B8%B8%E8%AF%86%E5%86%85%E5%AE%B9/">java 常识内容</a>
          </li>
        
          <li>
            <a href="/2022/12/20/java-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/">java 内存相关</a>
          </li>
        
          <li>
            <a href="/2022/12/10/%E6%BA%90%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81/">源码、补码、反码</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>